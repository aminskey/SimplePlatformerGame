# full importsfrom typing import Listimport pygame, sys, random, cv2# import specific methodsfrom pygame.locals import *from datetime import datetimefrom time import sleepfrom warnings import filterwarningsfrom os import listdirfrom os.path import isdirfrom sys import exitfrom pygame.math import Vector2# filter warningfilterwarnings('ignore', category=DeprecationWarning)# initiate sound and graphicspygame.mixer.init()pygame.init()# Create FPS handlerclock = pygame.time.Clock()# Resolutionwidth = 900height = 700# joystickgameIcon = pygame.image.load("icons/gameIcon.png")pygame.display.set_icon(gameIcon)p1Pad = Nonep2Pad = Noneif pygame.joystick.get_count() > 0:    p1Pad = pygame.joystick.Joystick(0)    p1Pad.init()if pygame.joystick.get_count() > 1:    p2Pad = pygame.joystick.Joystick(0)    p2Pad.init()    p1Pad = pygame.joystick.Joystick(1)    p1Pad.init()# resolution tupleres = (width, height)firstEntry = True# Game namename = 'Sky Dash Lite'# Setting up windowscreen = pygame.display.set_mode(res, FULLSCREEN | SCALED)pygame.display.set_caption(name)# Sprite Groupsclouds = pygame.sprite.Group()platforms = pygame.sprite.Group()all_sprites = pygame.sprite.Group()danger = pygame.sprite.Group()players = pygame.sprite.Group()seagulls = pygame.sprite.Group()decorations = pygame.sprite.Group()scanlineGroup = pygame.sprite.Group()projGroup = pygame.sprite.Group()bossGroup = pygame.sprite.Group()# text and screen backgroundBG = (52, 164, 235)BG2 = (100, 100, 255)# Invisible mousepygame.mouse.set_visible(False)# Initial Player speedPSD = 4# player speedPlayerSpeed = PSDCHANCE = 64# 1/32 = 3.125% chance of lava blockFPS = 50# Calculating Players position relative to startvec = pygame.math.Vector2# extrasdebug = TruescanlineBool = TruemultiBool = Falseended = False# for startscreenExit = FalsemaxSeqLen = 5# Clouds Classclass Clouds(pygame.sprite.Sprite):    # General settings    def __init__(self, pos, img="backgroundObjects/cloud.png", size=(150, 63), speed=1):        super().__init__()        self.image = pygame.image.load(img)        self.image = pygame.transform.scale(self.image, size)        self.rect = self.image.get_rect()        self.rect.center = pos        self.speed = speed    # Make them move in the air    def update(self, minHeight=0, speed=None):        x, y = self.rect.center        # if out of window then respawn ahead of widthspan        if x < -self.image.get_width() - 10:            random.seed(datetime.now())            x = width + self.image.get_width() + 10            y = random.randrange(minHeight, height)        # slowly drift backwards creating virtual effect        if speed == None:            x -= self.speed        else:            x -= speed        self.rect.center = (x, y)# platform mechanismclass Platform(pygame.sprite.Sprite):    # initial settings    # asking Program if landable    def __init__(self, Landable, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        width, height = surface.get_size()        # if there is no specific image then use random        # if not landable then use lava block image.        if image == None:            plat_dir = listdir('platforms/' + dir)            bad_dir = listdir('badObjects/' + dir)            plat_max_len = len(plat_dir) - 1            bad_max_len = len(bad_dir) - 1            for item in plat_dir:                if isdir(item):                    plat_max_len -= 1            for item in bad_dir:                if isdir(item):                    bad_max_len -= 1            if Landable:                self.image = pygame.image.load(                    'platforms/' + dir + '/platform_' + str(random.randint(0, plat_max_len)) + '.png')            else:                self.image = pygame.image.load(                    'badObjects/' + dir + '/badplat' + str(random.randint(0, bad_max_len - 1)) + '.png')        else:            self.image = pygame.image.load(image)        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        # General settings        self.rect = self.image.get_rect()        self.rect.center = (random.randrange(width * 1.25, width * 2), random.randrange(height * 8 // 12, height * 5 // 6))    # self.pos = vec((self.rect.center))# Seagulls classclass Seagull(pygame.sprite.Sprite):    # initial settings    def __init__(self, dir="ground", surface=screen, image=None):        super().__init__()        width, height = surface.get_size()        if image == None:            self.image = pygame.image.load('badObjects/' + dir + '/air/seagull.png')        else:            self.image = pygame.image.load(image)        self.rect = self.image.get_rect()        self.rect.center = (random.randint(width, width * 2), random.randint(0, height * 5 // 24))        self.x, self.y = self.rect.center    # Update mechanism    def update(self):        self.x -= PlayerSpeed * 1.15        self.rect.center = (self.x, self.y)        if pygame.sprite.spritecollide(self, players, False):            self.image = pygame.image.load("misc/explosion.png")            self.rect = self.image.get_rect()            self.rect.center = (self.x, self.y)        # if seagull is out of screen then kill it        if self.x < 0:            all_sprites.remove(self)            danger.remove(self)            seagulls.remove(self)            self.kill()class PlayerObject():    def __init__(self, name, sizeFactor, normalSize=False):        self.name = name        self.normalSize = normalSize        if not multiBool:            self.sideLength = 40        else:            self.sideLength = 35        self.sizeFactor = sizeFactor        self.image = pygame.image.load("players/"+name+".png")class Projectile(pygame.sprite.Sprite):    def __init__(self, pos, image="misc/fireball.png", size=1, direction=1, soundeffect=None):        super().__init__()        self.image = pygame.image.load(image)        self.image = pygame.transform.scale(self.image, (self.image.get_width()*size, self.image.get_height()*size))        self.rect = self.image.get_rect()        self.sender = None        self.rect.center = pos        self.pos = pos        self.damage = 0.05        self.counter = 0        self.max = 25        self.direction = direction        if soundeffect:            pygame.mixer.Sound(soundeffect).play()    def update(self):        self.counter += float(abs(self.direction))        self.rect.centerx += self.image.get_width()//2 * self.direction        if int(self.counter) >= self.max or pygame.sprite.spritecollideany(self, self.groups()[0]).sender != self.sender:            self.remove(projGroup)            self.kill()# Player classclass Player(pygame.sprite.Sprite):    # initial settings    def __init__(self, playerObject, AIMode=False, surf=screen, player1Bool=True):        super().__init__()        self.sideLength = playerObject.sideLength        # Temporary variable only used inside __init__ method        sizeFactor = playerObject.sizeFactor        self.image = playerObject.image        if not playerObject.normalSize:            self.image = pygame.transform.scale(self.image, (self.sideLength // sizeFactor, self.sideLength // sizeFactor))        self.blownup = pygame.image.load("misc/explosion.png")        self.rect = self.image.get_rect()        self.rect.center = (width // 2, 0)        self.health = 3        self.bossMode = False        self.acc = 0        self.relpos = vec(self.rect.center)        self.name = playerObject.name        self.jumpstate = True        self.dead = False        self.AIMode = AIMode        self.jumpGame = False        self.moveBools = [False, False]        if self.AIMode:            self.jumpstate = False        self.vel = 0        self.prevVel = 0        self.rectify_pos = False        # Can use powerups True|False        self.powerUpBool = True        self.powerUps = []        self.player1Bool = player1Bool        self.fric = -0.30        self.screen = surf        self.raceBool = False        self.raceSpeed = 2        self.canMove = True        self.regjump = True        self.enemy = None    def fire(self):        proj = Projectile((self.rect.midright[0] + 20, self.rect.midright[1]))        proj.sender = self        proj.add(projGroup)    def race(self, keys):        if self.rect.centerx <= width * 11//12:            if self.player1Bool:                if keys[K_RIGHT]:                    self.rect.centerx += 2                if keys[K_LEFT]:                    self.rect.centerx -= 2            else:                if keys[K_d]:                    self.vel += 2                if keys[K_a]:                    self.vel -= 2    def move(self, keys):        if self.player1Bool:            if keys[K_RIGHT]:                self.vel += PSD//4            if keys[K_LEFT]:                self.vel -= PSD//4        else:            if keys[K_d]:                self.vel += PSD//4            if keys[K_a]:                self.vel -= PSD//4        if self.vel >= PSD * 3:            self.vel = PSD * 3        elif self.vel <= -PSD * 3:            self.vel = -PSD * 3        if self.rect.midright[0] > width * 5//6:            # self.rect.midright = (width * 5//6, self.rect.midright[1])            self.rect.midright = (self.rect.midright[0] + self.vel, self.rect.midright[1])            # self.vel -= 1        elif self.rect.midleft[0] < width//6:            # self.rect.midleft = (width//6, self.rect.midleft[1])            self.rect.midleft = (self.rect.midleft[0] + self.vel, self.rect.midleft[1])            # self.vel += 1        else:            if self.vel != 0:                self.prevVel = self.vel            if self.vel < 0:                self.rect.centerx += self.vel - self.fric            if self.vel > 0:                self.rect.centerx += self.vel + self.fric            self.moveBools = [False, False]        if pygame.sprite.spritecollideany(self, platforms):            if self.vel < 0:                self.vel -= self.fric            if self.vel > 0:                self.vel += self.fric    # Jump mechanism    def jump(self, keys, jumpForce=20):        x, y = self.rect.center        # Event handling        if not self.AIMode:            if self.player1Bool:                if keys[K_SPACE]:                    # jumping                    y -= jumpForce            else:                if keys[K_w]:                    y -= jumpForce            if p1Pad != None:                if p1Pad.get_button(0):                    y -= jumpForce        else:            y -= jumpForce        # Updating position        self.rect.center = (x, y)    def AI(self):        if width * 4 // 6 >= self.rect.centerx > width // 6:            if self.raceBool and self.canMove:                oppGroup = pygame.sprite.Group()                oppGroup.add(self.enemy)                if pygame.sprite.spritecollideany(self, oppGroup):                    if self.jumpstate == True:                        self.jumpstate = False                    else:                        self.jumpstate = True                    self.rect.centerx -= 5                if self.enemy.rect.centerx > self.rect.centerx - 100 or self.enemy.rect.centerx < self.rect.centerx + 100:                    self.rect.centerx += self.raceSpeed                else:                    self.rect.centerx += self.raceSpeed * 2        else:            self.canMove = False        if self.rect.centerx <= width * 3 // 6:            self.canMove = True        if pygame.sprite.spritecollideany(self, projGroup):            self.jumpstate = True            if self.rect.centerx > width//3:                self.rect.centerx -= 8        elif pygame.sprite.spritecollideany(self, platforms):            self.jumpstate = False            if self.raceBool:                if self.rect.centerx < self.enemy.rect.centerx - 50:                    self.fire()            collided_platform = pygame.sprite.spritecollide(self, platforms, False)[-1]            next_platform = None            # Calculate index number for collided platform            index = 0            for plat in platforms.sprites():                if plat == collided_platform:                    try:                        next_platform = platforms.sprites()[index + 1]                        break                    except IndexError:                        next_platform = platforms.sprites()[index]                    break                index += 1            distance = (next_platform.rect.midleft[0] - collided_platform.rect.midright[0])            if distance <= 80 and self.rect.centery <= collided_platform.rect.midtop[0]:                self.jumpstate = False            elif distance <= 200 and self.rect.centery <= collided_platform.rect.midtop[0]:                if self.rect.y <= 10:                    self.jumpstate = False            elif self.rect.centerx >= collided_platform.rect.midright[0] or self.rect.centery >= collided_platform.rect.midtop[1]:                self.jumpstate = True    # Gravity mechanics    def gravity(self, gravityDecimal=0.5):        x, y = self.rect.center        # checking for collision        # If not then continue falling and updating position        if not pygame.sprite.spritecollide(self, platforms, False):            y += self.acc            self.acc += gravityDecimal            self.rect.center = (x, y)        # else stop and update position        else:            self.acc = 0            self.rect.center = (x, y)    # The Update mechanism    def update(self, jumpForce=20, gravity=0.5, otherGroup=danger, sender=None):        x, y = self.rect.midtop        keys = pygame.key.get_pressed()        # Updating Position        self.rect.midtop = (x, y)        if pygame.sprite.spritecollideany(self, platforms):            currPlat = pygame.sprite.spritecollide(self, platforms, False)[-1]            self.jumpstate = True            if self.rect.midtop[1] < currPlat.rect.midtop[1] and self.rect.centery > currPlat.rect.midtop[1]:                self.rect.centery = currPlat.rect.midtop[1]            elif self.rect.midtop[1] > currPlat.rect.midtop[1]:                if self.rect.centerx > currPlat.rect.midleft[0] and self.rect.centerx < currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midleft[0]                elif self.rect.centerx < currPlat.rect.midright[0] and self.rect.centerx > currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midright[0]        # Updating relative position        self.relpos.x += PlayerSpeed        if self.jumpGame:            self.move(keys)        if self.race and not self.AIMode:            self.race(keys)        if self.AIMode:            self.AI()        else:            if keys[K_x]:                sleep(0.005)                self.fire()        # If not in air allow jump mechanism        if self.jumpstate:            self.jump(keys, jumpForce)        # Running virtual gravity method        self.gravity(gravity)        if not self.regjump and self.AIMode:            self.jumpstate = False        if pygame.sprite.spritecollide(self, otherGroup, False):            if self.health <= 0:                self.image = pygame.image.load("misc/explosion.png")                self.image = pygame.transform.scale(self.image, (100, 100))                self.rect = self.image.get_rect()                self.rect.midtop = (x, y)                if self.AIMode:                    self.kill()            else:                if self.bossMode:                    self.health -= 0.05                else:                    self.health -= 1                self.jumpstate = True        if pygame.sprite.spritecollideany(self, projGroup):            proj = pygame.sprite.spritecollideany(self, projGroup)            if otherGroup.has(proj.sender):                self.health -= 1                proj.kill()class Boss(pygame.sprite.Sprite):    def __init__(self, name, fuel, delay=100):        super().__init__()        self.name = name        self.neutral = self.return_state_image("neutral")        self.image = self.neutral        self.rect = self.image.get_rect()        self.health = 10        self.acc_y = 0        self.max_gravity_acceleration = 10        self.jumpstate = False        self.enemy = None  # Sprite object        self.fuel = fuel        self.damage = 1.5        self.delay = delay        self.boundaries = [            screen.get_width()//6,            screen.get_width()//2,            screen.get_width()        ]        self.counter = 0    def gravity(self, acceleration=0.5):        self.rect.centery += self.acc_y        if self.acc_y < self.max_gravity_acceleration:            self.acc_y += acceleration    def jump(self, force=10):        if not self.jumpstate:            self.acc_y = -force            self.jumpstate = True    def return_state_image(self, state):        state = pygame.image.load("bosses/" + self.name + "/" + self.name + "-" + state + ".png")        return state    def fire(self, image="misc/fireball.png", direction=1, size=1, pos=(0, 0), max=5, soundeffect=None):        proj = Projectile(pos, image, size, direction, soundeffect)        proj.sender = self        proj.max = max        projGroup.add(proj)        self.fuel -= 1    def update(self):        if pygame.sprite.spritecollideany(self, projGroup):            proj = pygame.sprite.spritecollideany(self, projGroup)            if players.has(proj.sender):                self.health -= self.damage                pygame.mixer.Sound("sounds/pop.wav").play()        if self.health <= 0:            self.image = pygame.transform.scale(pygame.image.load("misc/explosion.png"), res)class Guard_01(Boss):    def __init__(self):        super().__init__("B-01", 1, 350)        self.up_img = self.return_state_image("up")        self.down_img = self.return_state_image("down")        self.small_img = self.return_state_image("small")        self.entrance_mode = True        self.speed = 4        self.rect.topright = (0, 0)        self.full = True        self.max_delay = 5        self.shot_delay = self.max_delay        self.damage = 0.025        self.started_playing = False        self.sounds = [            pygame.mixer.Sound("sounds/jet-1.wav"),            pygame.mixer.Sound("sounds/jet-2.wav"),            pygame.mixer.Sound("sounds/flame.wav")        ]        for sound in self.sounds:            sound.play()    def entrance(self):            if self.rect.midleft[0] > screen.get_width():                self.rect.center = (screen.get_width()*3, screen.get_height()//2)                self.entrance_mode = False            self.rect.centerx += self.speed * 6    def AI(self):        # distance from shooting range: player + 150 units (x-coordinates)        dist = (self.rect.midleft[0] - (self.enemy.rect.centerx), self.rect.midleft[1] - self.enemy.rect.centery)        if self.full:            if dist[0] <= 300:                if self.enemy.rect.centery > self.rect.centery + 50:                    self.rect.centery += self.speed                if self.enemy.rect.centery < self.rect.centery - 50:                    self.rect.centery -= self.speed                if abs(dist[1]) < 100:                    if self.shot_delay <= 0:                        self.fire("misc/lazer.png", -0.25, 3, (self.rect.midleft[0] + 10, self.rect.midleft[1] - 50), max=20, soundeffect="sounds/lazer_fire.wav")                        self.shot_delay = self.max_delay            else:                self.rect.centerx -= self.speed//2        else:            self.gravity(acceleration=-0.25)    def update(self):        if not self.full:            if self.fuel <= 10:                self.fuel += 0.05            else:                self.full = True        if self.fuel <= 0:            self.full = False        if self.entrance_mode:            self.entrance()        else:            self.AI()        if self.shot_delay > 0:            self.shot_delay -= 1        if self.health <= 0:            for sound in self.sounds:                sound.stop()        super().update()class Rampager(Boss):    def __init__(self):        super().__init__("rampager", 20)        self.boost_image = self.return_state_image("boost")        self.rect.midright = screen.get_rect().midleft    def AI(self):        if self.fuel >= 0:            self.image = self.neutral            if self.rect.midright[0] < self.enemy.rect.midleft[0] - 150:                self.rect.centerx += 2            else:                if self.rect.midleft[0] < screen.get_width():                    if self.enemy.rect.centerx > self.rect.midright[0]:                        sleep(0.00005)                        self.fire(size=10, pos=self.rect.midright, soundeffect="sounds/flame.wav")                else:                    self.rect.centerx -= 2        else:            self.boost()            if self.fuel < 150:                self.fuel += 0.0025            elif self.health < 5:                self.fire(size=10, pos=self.rect.midright, soundeffect="sounds/flame.wav")    def boost(self):        if self.image == self.neutral:            self.image = self.boost_image            self.rect.midright = self.rect.center        self.rect.centerx += 5    def update(self):        if not pygame.sprite.spritecollideany(self, platforms):            self.gravity()        else:            plat = pygame.sprite.spritecollideany(self, platforms)            if self.rect.centery >= plat.rect.midtop[1]:                self.jumpstate = False        self.AI()        self.jump()        self.rect.centerx -= 1        super().update()class PlatDecorations(pygame.sprite.Sprite):    def __init__(self, platform, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        self.ok = True        if image != None:            self.image = pygame.image.load(image)        else:            decor_max_len = len(listdir('decorations/' + dir)) - 1            self.image = pygame.image.load(                'decorations/' + dir + '/decor_' + str(random.randint(0, decor_max_len)) + '.png')        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        if platform == None:            print("Cannot summon decoration, specified platform is None")            self.ok = False        self.rect = self.image.get_rect()        self.platform = platform        self.surface = surface        self.image.set_alpha(200)    def update(self):        self.rect.midbottom = self.platform.rect.midtop        x, y = self.rect.midbottom        self.rect.midbottom = (x, y + self.image.get_height() * 1 // 6)        if self.rect.centerx <= 0:            self.kill()class PlayerTag(pygame.sprite.Sprite):    def __init__(self, player, number):        super().__init__()        font = pygame.font.Font("fonts/pixelart.ttf", 40)        self.image = font.render(number, BG2, (55, 255, 55))        self.num = number        self.player = player        self.rect = self.image.get_rect()        self.rect.midbottom = self.player.rect.midtop    def update(self):        self.rect.midbottom = self.player.rect.midtop        if not self.player:            self.kill()# Levels Classclass Level():    def __init__(self, bg, spriteDirs, song, startblock, factor=1, playerStartSpeed=PSD, moveBool=False, gravity=0.5, jumpForce=20, name="Unknown Level", diff="easy", zoomMode=False, boss=None, acc=1):        self.bg = bg        self.factor = factor        self.diff = diff        self.name = name        self.acc = acc        self.zoomMode = zoomMode        if self.bg != None:            self.noBG = False            self.bg = "backgrounds/" + bg        else:            self.noBG = True            self.bg = "backgrounds/Unknown.png"        self.bgSong = song        self.length = 4100        self.fl = 1700        self.platDir, self.cloud = spriteDirs        self.jumpForce = jumpForce        self.gravity = gravity        self.psd = playerStartSpeed        self.moveBool = moveBool        self.startblock = startblock        self.boss = boss    def loadBG(self, res):        self.image = pygame.image.load(self.bg)        if self.zoomMode:            self.image = pygame.transform.scale(self.image, (res[0]*2, res[1]*2)).convert()        else:            self.image = pygame.transform.scale(self.image, res)        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, res[1])class CoopLevel():    def __init__(self, backgrounds, spriteDir, startblock, song, factor=1, gravity=0.5, jumpForce=20, PlayerStartSpeed=PSD, moveBool=False, name="Unknown Level", diff="easy"):        self.bg1 = backgrounds        self.bgSong = song        self.name = name        self.bg1 = "backgrounds/dual-BGs/" + self.bg1        self.startblock = startblock        self.diff = diff        self.factor = factor        self.platDir = spriteDir        self.psd = PlayerStartSpeed        self.moveBool = moveBool        self.gravity = gravity        self.jumpForce = jumpForce    def loadBG(self, size1):        self.image1 = pygame.image.load(self.bg1)        self.image1 = pygame.transform.scale(self.image1, size1)        self.rect1 = self.image1.get_rect()        self.rect2 = self.image1.get_rect()        self.rect1.topleft = (0, 0)        self.rect2.topleft = (0, -self.image1.get_height()//2)class Line(pygame.sprite.Sprite):    def __init__(self, thickness, alpha, color, pos, length=screen.get_width()):        super().__init__()        self.alpha = alpha        self.image = pygame.Surface((length, thickness))        self.image.fill(color)        self.image.set_alpha(self.alpha)        self.rect = self.image.get_rect()        self.rect.topleft = posclass Text(pygame.sprite.Sprite):    def __init__(self, str, BG_FG_Color, script, pos=(0,0)):        super().__init__()        self.msg = str        self.image = script.render(str, BG_FG_Color[0], BG_FG_Color[1])        self.rect = self.image.get_rect()        self.rect.center = posclass HealthBar(pygame.sprite.Sprite):    def __init__(self, player, surf):        super().__init__()        self.images = [            pygame.image.load("healthbars/bar0.png"),            pygame.image.load("healthbars/bar1.png"),             pygame.image.load("healthbars/bar2.png"),             pygame.image.load("healthbars/bar3.png")        ]        self.image = self.images[-1]        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, surf.get_height())        self.player = player    def update(self, override=None):        if not override:            self.image = self.images[int(self.player.health)]        else:            self.image = self.images[int(override)]class PlayerCard(pygame.sprite.Sprite):    def __init__(self, player):        super().__init__()        self.image = pygame.Surface((screen.get_width()//3 - 50, screen.get_height() * 2//3))        self.rect = self.image.get_rect()        self.image.fill((0, 0, 0))        self.image.set_alpha(200)        self.player_img = pygame.transform.scale(player.image, (self.image.get_width() * 5//6, self.image.get_width() * 5//6))        self.player_rect = self.player_img.get_rect()        self.player_rect.topleft = (self.image.get_width() * 1//12, self.image.get_width() * 1//12)        tmp_font = pygame.font.Font("fonts/pixelart.ttf", 50)        self.name = player.name        self.player = player        self.name_obj = Text(player.name, (None, (155, 155, 155)), tmp_font)        self.name_obj.image.set_alpha(200)        self.name_obj.rect.center = (self.image.get_width()//2, self.image.get_height()*5//6)        self.image.blit(self.player_img, self.player_rect)        self.image.blit(self.name_obj.image, self.name_obj.rect)storymode_1 = [    Level("galaxy.png", ("space", None), "galaxy.ogg", "platform_5.png", 10, 11, False, 0.15, 10, "Outside The Milky Way", zoomMode=False),    Level("pluto.png", ("space", None), "pluto.ogg", "platform_5.png", 10, 11, False, 0.15, 10, "Pluto", zoomMode=True),    Level("pluto.png", ("space", None), "boss-fight.ogg", "platform_5.png", 10, 11, False, 0.15, 10, "Rampager Incoming", boss=Rampager)]storymode_2 = [    Level("exoplanet.png", ("ground", "cloud.png"), "water-moon.ogg", "platform_5.png", 10, 11, False, 0.15, 10, "Water Moon", zoomMode=False),    Level("saturn.png", ("space", None), "saturn.ogg", "platform_5.png", 10, 11, False, 0.15, 10, "Saturn Orbit", zoomMode=True),    Level("saturn.png", ("space", None), "pluto.ogg", "platform_5.png", 10, 11, False, 0.15, 10, "Boss Fight!!", boss=Rampager)]storymode_3 = [    Level("nebula.png", ("neon", None), "nebula.ogg", "platform_4.png", 10, 11, False, 0.25, 15, "Somewhere", zoomMode=True),    Level("planet-orbit.png", ("neon", "cloud.png"), "planet-orbit.ogg", "platform_4.png", 10, 1, False, 0.75, 15, "Chill Clouds", acc=0.35),    Level("planet-orbit.png", ("neon", None), "border-guard.ogg", "platform_4.png", 10, 11, False, 0.75, 15, "Border Guard Incoming", boss=Guard_01)]storymodes = [    storymode_1,    storymode_3,    storymode_2]def scanlines(thickness):    if scanlineBool:        for i in range(screen.get_height()):            if i % (thickness * 4) == 0:                tmp_line = Line(thickness, 100, (0, 0, 0), (0, i))                tmp_line.image.set_alpha(100)                scanlineGroup.add(tmp_line)scanlines(1)def returnFrames(src, size, transparency=False):    slides = cv2.VideoCapture(src)    imageList = []    while True:        ret, frame = slides.read()        if not ret:            break        shape = frame.shape[1::-1]        img = pygame.image.frombuffer(frame.tobytes(), shape, "BGR").convert_alpha()        img = pygame.transform.scale(img, size)        if transparency:            img.set_colorkey((255, 255, 255))        imageList.append(img)    slides.release()    return imageListloading = pygame.image.load("backgrounds/loading.png")loading = pygame.transform.scale(loading, res)screen.blit(loading, (0, 0))pygame.display.update()lvlSelect_Anim = returnFrames("backgrounds/levelSelect.gif", res)startup_1 = returnFrames("backgrounds/startup-1.gif", res)startup_2 = returnFrames("backgrounds/startup-2.gif", res)help_bg = returnFrames("backgrounds/help.gif", res)easter_egg = returnFrames("backgrounds/levelSelect-2.gif", res)boss_alert = returnFrames("backgrounds/red_alert.gif", res)playersList = [    PlayerObject("wasp", 1),    PlayerObject("stingray", 1),    PlayerObject("green", 1)]enemy = PlayerObject("boss1", 1, True)enemy2 = PlayerObject("enemy_2", 1)antagonist = PlayerObject("red", 1)enemyFreq = [1, 10]dummy1 = [playersList[0], True]dummy2 = [enemy2, True]mainPlayer = Nonedef bossLevel(level, p1):    healthbarGroup = pygame.sprite.Group()    textGroup = pygame.sprite.Group()    monitorGroup = pygame.sprite.Group()    for item in danger:        item.remove(projGroup)        item.remove(danger)        item.kill()    for player in players.sprites():        player.remove(players)        player.kill()    for boss in bossGroup.sprites():        boss.remove(bossGroup)        boss.kill()    for item in platforms.sprites():        item.remove(platforms)        item.remove(all_sprites)        item.kill()    p1Object, p1AIBool = p1    player1 = Player(p1Object, p1AIBool)    level_boss = level.boss()    player1.bossMode = True    player1.enemy = level_boss.enemy    level_boss.enemy = player1    level.zoomMode=False    level.loadBG(res)    level.rect.bottomleft = screen.get_rect().bottomleft    font = pygame.font.Font("fonts/ka1.ttf", 35)    p1Healthbar = HealthBar(player1, screen)    healthbarGroup.add(p1Healthbar)    p1Healthbar.rect.topleft = (0, 0)    player1.raceBool = True    players.add(player1)    bossGroup.add(level_boss)    plat1 = Platform(True, image="platforms/" + level.platDir + "/" + level.startblock)    plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 2, plat1.image.get_height() * 2))    plat1.rect = plat1.image.get_rect()    plat1.rect.midleft = (width//2, screen.get_height() * 10/12)    main_y_coord = plat1.rect.midtop[1]    tmp_plat = Platform(True, image="platforms/" + level.platDir + "/" + level.startblock)    tmp_plat.rect.midleft = plat1.rect.midright    platforms.add(plat1)    platforms.add(tmp_plat)    player1.rect.midbottom = plat1.rect.midtop    p1Name = Text(player1.name, (None, (255, 255, 255)), font, (0, 0))    p1Name.rect.topleft = p1Healthbar.rect.bottomleft    textGroup.add(p1Name)    font = pygame.font.Font("fonts/ka1.ttf", 50)    speed = 1    ended = False    color = (155, 155, 155)    p1Wins = Text("Boss Defeated", (None, color), font, (screen.get_width() // 2, screen.get_height() // 2))    p2Wins = Text("You Lose!!", (None, color), font, (screen.get_width() // 2, screen.get_height() // 2))    finalWin = None    acc = 0.1    counter = 0    loss = False    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_ESCAPE:                    enterOpp()                    startScreen()                    exit()        for player in players.sprites():            player.rect.centerx -= 1            if not ended:                if player.rect.centery > height or player.rect.midright[0] < 0 or player.rect.midleft[0] > width:                    player.health = 0        if not ended:            if speed <= 200:                speed += acc        else:            if speed >= 10:                speed -= 0.3            else:                speed = 10        for plat in platforms:            plat.rect.centerx -= int(speed)            if plat.rect.midright[0] < -15:                plat.remove(platforms)                plat.kill()        for i in range(10):            new_plat = Platform(True, dir=level.platDir)            new_plat.rect.midtop = (new_plat.rect.centerx, main_y_coord)            if pygame.sprite.spritecollideany(new_plat, platforms):                new_plat.kill()            else:                new_plat.add(platforms)        if level_boss.health <= 0:            ended = True            finalWin = p1Wins        if player1.health <= 0:            ended = True            loss = True            finalWin = p2Wins            player1.image = player1.blownup        players.update(level.jumpForce, level.gravity, otherGroup=bossGroup)        projGroup.update()        healthbarGroup.update()        monitorGroup.update()        screen.blit(level.image, level.rect)        players.draw(screen)        projGroup.draw(screen)        if (counter//FPS) >= level_boss.delay:            bossGroup.update()            bossGroup.draw(screen)        if ended:            screen.blit(finalWin.image, finalWin.rect)            enterOpp(font="fonts/ka1.ttf", msg=finalWin.msg)            if loss:                startScreen()                exit()            else:                break        platforms.draw(screen)        healthbarGroup.draw(screen)        textGroup.draw(screen)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)        counter += speeddef levelSelect(list, func, lvlSelect_Anim=easter_egg):    font = pygame.font.Font("fonts/pixelart.ttf", 20)    headerFont = pygame.font.Font("fonts/segaArt.ttf", 70)    fontColor = (64, 125, 120)    headerColor = (69, 129, 181)    levelMenu = pygame.Surface((screen.get_width() * 2 // 3, screen.get_height()))    menuRect = levelMenu.get_rect()    menuRect.topleft = (screen.get_width() // 3, 0)    cursor = font.render(">", BG2, (55, 255, 55))    cursorRect = cursor.get_rect()    cursorRect.topleft = (0, 0)    prevWin = pygame.Surface((screen.get_width() // 3 - 20, screen.get_height() // 4))    prevRect = prevWin.get_rect()    prevRect.topleft = (10, screen.get_height() // 4)    win1 = pygame.Surface((screen.get_width()//3, screen.get_height()))    win2 = pygame.Surface((win1.get_width(), win1.get_height()))    win1.fill((0, 0, 0))    win2.fill((0, 0, 0))    win1Rect = win1.get_rect()    win2Rect = win2.get_rect()    win1Rect.topleft = (0, 0)    win2Rect.topright = (screen.get_width(), 0)    win1Prev = pygame.Surface((160, 160))    win2Prev = pygame.Surface((win1Prev.get_width(), win1Prev.get_height()))    prev1Rect = win1Prev.get_rect()    prev2Rect = win2Prev.get_rect()    prev1Rect.center = win1Rect.center    prev2Rect.center = win2Rect.center    lineList = []    bgList = []    diffList = []    playerSelect = Text("Select Character", (None, headerColor), headerFont, (screen.get_width()//2, 50))    player1 = Text("Player 1", (None, fontColor), font, (win1.get_width()//2, win1.get_height()//3))    player2 = Text("Player 2", (None, fontColor), font, (win2Rect.topleft[0] + win2.get_width()//2, win2.get_height()//3))    p1 = font.render("Player 1:", BG2, fontColor)    p2 = font.render("Player 2:", BG2, fontColor)    header = font.render("AI On/Off", BG2, (131, 214, 153))    p1On = font.render("On", BG2, (55, 255, 55))    p1Off = font.render("Off", BG2, (55, 255, 55))    p2On = font.render("On", BG2, (55, 255, 55))    p2Off = font.render("Off", BG2, (55, 255, 55))    p1_state = [True, False]    p2_state = [True, False]    p1Rect = p1.get_rect()    p2Rect = p2.get_rect()    headerRect = header.get_rect()    p1OnRect = p1On.get_rect()    p1OffRect = p1Off.get_rect()    p2OnRect = p2On.get_rect()    p2OffRect = p2Off.get_rect()    p1Itr = 1    p2Itr = 1    p1Object = None    p2Object = None    i = 0    for level in list:        tmp = font.render(level.name, BG2, fontColor)        tmpRect = tmp.get_rect()        tmpRect.topleft = (20, i * tmp.get_height() + 5)        diff = font.render(level.diff, BG2, (152, 32, 32))        diffRect = diff.get_rect()        lineList.append((tmp, tmpRect, level))        diffList.append((diff, diffRect))        if not multiBool:            image = pygame.image.load(level.bg)            image = pygame.transform.scale(image, prevWin.get_size())            rect = image.get_rect()            rect.topleft = (0, 0)            bgList.append((image, rect))        else:            image = pygame.image.load(level.bg1)            image = pygame.transform.scale(image, prevWin.get_size())            rect = image.get_rect()            rect.topleft = (0, 0)            bgList.append((image, rect))        i += 1    # clear rubish from screen    screen.fill((0, 0, 0))    itr = 0    row = 0    itrRow = [p1Itr, p2Itr]    run = True    mainLevel = None    index = 0    while run:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_UP]:                    if itr <= 0:                        itr = len(lineList) - 1                    else:                        itr -= 1                    break                if keys[K_DOWN]:                    if itr >= len(lineList) - 1:                        itr = 0                    else:                        itr += 1                    break                if keys[K_RETURN]:                    if multiBool:                        mainLevel = level                        run = False                        break                    else:                        # Needs to be fixed                        return itr                    startScreen()                    break                if keys[K_ESCAPE]:                    enterOpp()                    startScreen()                    break        tmp, lnRect, level = lineList[itr]        bgImage, bgRect = bgList[itr]        diff, diffRect = diffList[itr]        diffRect.topleft = prevRect.bottomleft        cursorRect.midright = lnRect.midleft        if index >= len(lvlSelect_Anim) - 1:           index = 0           continue        else:           index += 1        bg = lvlSelect_Anim[index]        screen.blit(bg, (0, 0))        levelMenu.fill((0, 0, 0))        levelMenu.set_alpha(150)        prevWin.blit(bgImage, bgRect)        screen.blit(diff, diffRect)        for line in lineList:            lineIMG, lineRect, tmp = line            levelMenu.blit(lineIMG, lineRect)        levelMenu.blit(cursor, cursorRect)        screen.blit(levelMenu, menuRect)        screen.blit(prevWin, prevRect)        scanlineGroup.draw(prevWin)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)    run = True    selectPlayers = True    if multiBool:        win1.set_alpha(125)        win2.set_alpha(125)        index = 0        p1Index = 0        p2Index = 1        while selectPlayers:            for event in pygame.event.get():                if event.type == pygame.QUIT:                    pygame.quit()                    exit()                if event.type == pygame.KEYDOWN:                    keys = pygame.key.get_pressed()                    if keys[K_RIGHT]:                        p1Index += 1                    if keys[K_LEFT]:                        p1Index -= 1                    if keys[K_d]:                        p2Index += 1                    if keys[K_a]:                        p2Index -= 1                    if keys[K_RETURN]:                        p1Object = playersList[p1Index]                        p2Object = playersList[p2Index]                        selectPlayers = False                        break                    if keys[K_ESCAPE]:                        levelSelect(list, func)            if index >= len(lvlSelect_Anim) - 1:                index = 0                continue            else:                index += 1            bg = lvlSelect_Anim[index]            if p1Index > len(playersList) - 1:                p1Index = 0            if p1Index < 0:                p1Index = len(playersList) - 1            if p2Index > len(playersList) - 1:                p2Index = 0            if p2Index < 0:                p2Index = len(playersList) - 1            img1 = pygame.transform.scale(playersList[p1Index].image, win1Prev.get_size())            img2 = pygame.transform.scale(playersList[p2Index].image, win2Prev.get_size())            p1Name = Text(playersList[p1Index].name, (None, headerColor), font, (win1.get_width()//2, win1.get_height() * 2//3))            p2Name = Text(playersList[p2Index].name, (None, headerColor), font, (win2Rect.topleft[0] + win2.get_width()//2, win2.get_height() * 2//3))            win1Prev.blit(img1, (0, 0))            win2Prev.blit(img2, (0, 0))            screen.blit(bg, (0, 0))            screen.blit(win1, win1Rect)            screen.blit(win2, win2Rect)            screen.blit(win1Prev, prev1Rect)            screen.blit(win2Prev, prev2Rect)            screen.blit(p1Name.image, p1Name.rect)            screen.blit(p2Name.image, p2Name.rect)            screen.blit(playerSelect.image, playerSelect.rect)            screen.blit(player1.image, player1.rect)            screen.blit(player2.image, player2.rect)            scanlineGroup.draw(screen)            pygame.display.update()            clock.tick(30)        while run:            for event in pygame.event.get():                if event.type == pygame.QUIT:                    pygame.quit()                    exit()                if event.type == pygame.KEYDOWN:                    keys = pygame.key.get_pressed()                    if keys[K_ESCAPE]:                        levelSelect(list, func)                        break                    if keys[K_RETURN]:                        enterOpp()                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        pygame.mixer.music.load("songs/" + mainLevel.bgSong)                        pygame.mixer.music.play(-1)                        func(mainLevel, p1=mainPlayer)                        break                    if keys[K_DOWN]:                        row += 1                        break                    if keys[K_UP]:                        row -= 1                        break                    if keys[K_RIGHT]:                        itrRow[row] += 1                        break                    if keys[K_LEFT]:                        itrRow[row] -= 1                        break            if itrRow[row] < 0:                itrRow[row] = 1            if itrRow[row] > 1:                itrRow[row] = 0            if row < 0:                row = 1            elif row > 1:                row = 0            p1Rect.center = (screen.get_width() // 3, screen.get_height() // 2 - 10)            p2Rect.center = (screen.get_width() // 3, screen.get_height() // 2 + 10)            headerRect.center = (screen.get_width() // 2, screen.get_height() // 2 - 50)            p1OnRect.center = (screen.get_width() * 2 // 3, screen.get_height() // 2 - 10)            p2OnRect.center = (screen.get_width() * 2 // 3, screen.get_height() // 2 + 10)            p1OffRect.center = p1OnRect.center            p2OffRect.center = p2OnRect.center            if index >= len(lvlSelect_Anim) - 1:                index = 0                continue            else:                index += 1            bg = lvlSelect_Anim[index]            screen.blit(bg, (0, 0))            if p1_state[itrRow[0]]:                screen.blit(p1On, p1OnRect)            else:                screen.blit(p1Off, p1OffRect)            if p2_state[itrRow[1]]:                screen.blit(p2On, p2OnRect)            else:                screen.blit(p2Off, p2OffRect)            if row == 0:                cursorRect.midright = p1OnRect.midleft            elif row == 1:                cursorRect.midright = p2OnRect.midleft            screen.blit(p1, p1Rect)            screen.blit(p2, p2Rect)            screen.blit(cursor, cursorRect)            screen.blit(header, headerRect)            scanlineGroup.draw(screen)            pygame.display.update()            clock.tick(30)def playerSelect():    cards = []    for item in playersList:        cards.append(PlayerCard(item))    cards[0].rect.midleft = screen.get_rect().midleft    cards[1].rect.center = screen.get_rect().center    cards[2].rect.midright = screen.get_rect().midright    title = Text("Select Character", (None, (255, 255, 50)), pygame.font.Font("fonts/headkick.ttf", 75))    title.rect.midtop = screen.get_rect().midtop    global CHANCE    global mainPlayer    playerIndex = 0    gifIndex = 0    keys_pressed = []    codePass = False    sequence = [K_SPACE, K_UP, K_DOWN, K_a, K_s]    while True:        cursor_1 = Text(">" + cards[playerIndex].name + " selected<", (None, (0, 255, 0)), pygame.font.Font("fonts/pixelart.ttf", 30))        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYUP:                keys_pressed.append(event.key)                break            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_LEFT:                    playerIndex -= 1                    break                if event.key == pygame.K_RIGHT:                    playerIndex += 1                    break                if event.key == pygame.K_ESCAPE:                    enterOpp()                    startScreen()                    break                if event.key == pygame.K_RETURN:                    i = 0                    while i < len(storymodes[playerIndex]):                        mainPlayer = Player(cards[playerIndex].player)                        if codePass:                            enterOpp()                            pygame.mixer.music.stop()                            pygame.mixer.music.unload()                            pygame.mixer.music.load("songs/easter_egg.ogg")                            pygame.mixer.music.play(-1)                            i = levelSelect(storymodes[playerIndex], main)                            codePass = False                        CHANCE = 64                        item = storymodes[playerIndex][i]                        enterOpp(msg=item.name)                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        if item.boss:                            incoming_boss()                            pygame.mixer.music.load("songs/" + item.bgSong)                            pygame.mixer.music.play(-1)                            bossLevel(item, (cards[playerIndex].player, False))                        else:                            main(item, p1=mainPlayer)                        i += 1                    pygame.mixer.music.load("songs/level-select.ogg")                    pygame.mixer.music.play(-1)        if not codePass:            if len(keys_pressed) >= maxSeqLen:                for i in range(maxSeqLen):                    if not keys_pressed[-i] == sequence[-i]:                        codePass = False                        keys_pressed.clear()                        break                    else:                        codePass = True        gifIndex += 1        if gifIndex >= len(lvlSelect_Anim):            gifIndex = 0        bg = lvlSelect_Anim[gifIndex]        if playerIndex >= len(cards):            playerIndex = 0        if playerIndex < 0:            playerIndex = len(cards) - 1        cursor_1.rect.midtop = cards[playerIndex].rect.midbottom        screen.blit(bg, (0, 0))        screen.blit(title.image, title.rect)        for item in cards:            screen.blit(item.image, item.rect)        screen.blit(cursor_1.image, cursor_1.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def incoming_boss():    i = 0    gifIndex = 0    pygame.mixer.music.load("sounds/boss_alert.ogg")    pygame.mixer.music.play(-1)    for i in range(100):        gifIndex += 1        if gifIndex >= len(boss_alert):            gifIndex = 0        bg = boss_alert[gifIndex]        screen.blit(bg, (0, 0))        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(10)    enterOpp()def main(tmpLvl, p1=None, playerSpeed=0):    for plat in platforms:        plat.remove(all_sprites)        plat.remove(platforms)        plat.kill()    for item in danger:        item.remove(danger)        item.remove(all_sprites)        item.remove(platforms)        item.kill()    for item in decorations:        item.remove(all_sprites)        item.remove(decorations)        item.kill()    for item in clouds:        item.remove(all_sprites)        item.remove(clouds)        item.kill()    for item in danger:        item.remove(all_sprites)        item.remove(danger)        item.kill()    players.empty()    all_sprites.empty()    pygame.mixer.music.load("songs/" + tmpLvl.bgSong)    pygame.mixer.music.play(-1)    screen.fill((0, 0, 0))    pygame.display.update()    initDist = 0    if p1 != None:        initDist = p1.relpos.x        if p1.relpos.x < 0:            p1.relpos.x = 4        else:            p1.relpos.x += 51    p1.raceBool = True    enemyGroup = pygame.sprite.Group()    healthBars = pygame.sprite.Group()    if tmpLvl.noBG:        tmpLvl.bg = None    if tmpLvl.bg != None:        tmpLvl.loadBG(res)    MTLength = tmpLvl.length    print(MTLength)    cloudsGroup2 = pygame.sprite.Group()    # Creating background clouds    if tmpLvl.cloud != None:        for i in range(40):            new_cloud = Clouds((random.randrange(0, width), random.randrange(0, height)), "backgroundObjects/" + tmpLvl.cloud)            if i > 20:                new_cloud.image.set_alpha(220)                new_cloud.speed = 2                clouds.add(new_cloud)            else:                new_cloud.speed = 1                new_cloud.image.set_alpha(165)                if not pygame.sprite.spritecollide(new_cloud, clouds, False):                    clouds.add(new_cloud)        for i in range(10):            new_cloud = Clouds((random.randrange(0, width), random.randrange(height * 2//3, height)), "backgroundObjects/" + tmpLvl.cloud, size=(225, 95))            new_cloud.image.set_alpha(128)            if not pygame.sprite.spritecollideany(new_cloud, cloudsGroup2):                cloudsGroup2.add(new_cloud)    # Importing global variables    global PlayerSpeed    global CHANCE    global enemyFreq    playerLives = 3    if playerSpeed == 0:        PlayerSpeed = tmpLvl.psd    else:        PlayerSpeed = playerSpeed    # defining player    if p1 == None:        p1 = Player(playersList[0])    all_sprites.add(p1)    players.add(p1)    # Defining ground platform    plat1 = Platform(True, "platforms/" + tmpLvl.platDir + '/' + tmpLvl.startblock)    # Customizing platform    plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 3, plat1.image.get_height() * 3))    plat1.rect = plat1.image.get_rect()    plat1.rect.topleft = (50, height * 5 // 6 + 3)    plat2 = Platform(True, "platforms/" + tmpLvl.platDir + '/platform_0.png')    plat2.rect.center = (width * 1.25, height * 4 // 6)    # Add initial platform to groups    platforms.add(plat1)    all_sprites.add(plat1)    platforms.add(plat2)    all_sprites.add(plat2)    # loop the background music    # pygame.mixer.music.play(-1)    platnum = 0    decor_plat = None    # Creating font object    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    index = 0    if tmpLvl.zoomMode:        bgBottomLeft = tmpLvl.rect.bottomleft[1] + 50    else:        bgBottomLeft = tmpLvl.rect.bottomleft[1]    countVal = 250    checkMode = False    intensity = 1    p1_healthBar = HealthBar(p1, screen)    healthBars.add(p1_healthBar)    fightmode = False    while True:        # Highscore display        hs1 = Text("Current Level:", (BG2, (55, 255, 55)), sub, (0, 0))        hs2 = Text(str(tmpLvl.name), (BG2, (55, 255, 55)), sub, (0, 0))        hs1.rect.center = (width * 6 // 16, hs1.image.get_height())        hs2.rect.center = (width * 11 // 16, hs2.image.get_height())        # PlayerSpeed Text        ps1 = sub.render('Player Speed:', BG2, (55, 255, 55))        ps2 = sub.render(str(int(PlayerSpeed)), BG2, (55, 255, 55))        # Rectangle        ps1Rect = ps1.get_rect()        ps2Rect = ps2.get_rect()        # Position        ps1Rect.center = (width * 6 // 16, ps1.get_height() * 3)        ps2Rect.center = (width * 11 // 16, ps2.get_height() * 3)        # HUD Player text        score1 = sub.render('Player Distance', BG2, (55, 255, 55))        score2 = sub.render(str(int(p1.relpos.x // FPS)), BG2, (55, 255, 55))        # text rectangle        score1Rect = score1.get_rect()        score2Rect = score2.get_rect()        # Positioning text        score1Rect.center = (width * 6 // 16, score1.get_height() * 2)        score2Rect.center = (width * 11 // 16, score2.get_height() * 2)        # Window event handler        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        # Making the platforms move to create an illusion        # That the player is moving        for plat in platforms:            px, py = plat.rect.center            px -= PlayerSpeed            plat.rect.center = (px, py)        # Put in for loop for user to increase game intensity        for i in range(1):            # randomizing chance            # same logic as the seagull (l. 399) but with lava blocks            # but not dependent on distance            random.seed(datetime.now())            choice = random.randint(0, CHANCE)            new_plat = None            if choice == 0:                if (p1.relpos.x // FPS) > 750 and not fightmode:                    new_plat = Platform(False, None, tmpLvl.platDir)                    danger.add(new_plat)            else:                if fightmode:                    new_plat = Platform(True, "platforms/" + tmpLvl.platDir + "/" + tmpLvl.startblock)                    new_plat.rect.centery = screen.get_height() * 5//6                else:                    new_plat = Platform(True, None, tmpLvl.platDir)                platnum += 1                decor_plat = new_plat            # if platforms overlap            # remove them            if new_plat:                if not pygame.sprite.spritecollide(new_plat, platforms, False):                    platforms.add(new_plat)                    all_sprites.add(new_plat)                else:                    new_plat.kill()        if (p1.relpos.x//FPS) > tmpLvl.fl:            fightmode = True            p1.raceBool = True        # checking if the player died        # If it happened then reset settings and run gameOver method        if p1.rect.centery > height * 3//2 or pygame.sprite.spritecollide(p1, danger, False) or p1.rect.midright[0] < 0 or p1.health <= 0:            playerLives -= 1            if playerLives <= 0:                PlayerSpeed = tmpLvl.psd                CHANCE = 128                for item in decorations:                    all_sprites.add(item)                for item in clouds:                    item.remove(clouds)                    item.kill()                for plat in platforms:                    plat.remove(all_sprites)                    plat.remove(platforms)                    plat.kill()                gameOver(p1)            else:                pygame.mixer.Sound("sounds/pop.wav").play()                p1.rect.center = screen.get_rect().midtop        # if platform is out of screen or if there are more than 10 platforms then destroy        i = 0        for plat in platforms:            i += 1            px, py = plat.rect.topright            if px <= -50 or i > 10:                plat.kill()        # Seagull spawning after player distance 50000/FPS Rate        if (p1.relpos.x//FPS) > 1500:            # Chance of a seagull spawning            choice = random.randint(0, CHANCE)            # If true then spawn            if choice == 0:                for i in range(random.randrange(0, 3)):                    new_seagull = Seagull(tmpLvl.platDir)                    if not pygame.sprite.spritecollide(new_seagull, seagulls, False):                        seagulls.add(new_seagull)                        all_sprites.add(new_seagull)                        danger.add(new_seagull)        if (p1.relpos.x//FPS) > MTLength and p1.relpos.x != 0:            pygame.mixer.music.unload()            enterOpp(msg="Zone Complete")            return        # When players score divided by factor number gives a remainder of 0.        # And if player score not zero its self        countVal -= 0.0025        if countVal < 25:            countVal = 300        if p1.relpos.x % (countVal) // tmpLvl.factor == 0 and p1.relpos.x != 0:            PlayerSpeed += tmpLvl.acc            # 1/chancenumber divided by 1005/1000            if (p1.relpos.x//FPS) > 750:                if not fightmode:                    CHANCE //= 1.00005 * tmpLvl.acc        if fightmode:            if (p1.relpos.x//FPS) > tmpLvl.fl + 100:                num = random.randint(enemyFreq[0], enemyFreq[1])                if enemyFreq[0] > enemyFreq[1]//2:                    enemyFreq[0] = 1                if num <= enemyFreq[0]:                    enemyFreq[0] += 1                    tmp = Player(enemy2, True)                    tmp.rect.midright = (-20, screen.get_height() * 2//3)                    tmp.AIMode = True                    tmp.enemy = p1                    p1.enemy = tmp                    tmp.raceBool = True                    tmp.player1Bool = False                    tmp.health = 0.5                    tmp.regjump = False                    enemyGroup.add(tmp)        if p1.relpos.x % (countVal * 10) // tmpLvl.factor == 0 and p1.relpos.x < 0:            intensity += 1        while len(enemyGroup.sprites()) > intensity:            tmp = enemyGroup.sprites()[-1]            tmp.remove(enemyGroup)            tmp.kill()        if platnum % 20 == 0 and platnum > 0:            new_decor = PlatDecorations(decor_plat, None, tmpLvl.platDir)            if new_decor.ok == False:                new_decor.kill()            if pygame.sprite.spritecollide(new_decor, decorations, False):                new_decor.kill()            else:                decorations.add(new_decor)        for decor in decorations:            x, y = decor.rect.center            if x < 0 - screen.get_width() * 2:                decor.image.set_alpha(0)                decorations.remove(decor)                decor.kill()        if p1.rect.centerx < width//3 or p1.rect.centerx > width * 2//3:            checkMode = True        if checkMode:            if p1.rect.centerx < width//2:                p1.rect.centerx += 1            elif p1.rect.centerx > width//2:                p1.rect.centerx -= 1            else:                checkMode = False        for opp in enemyGroup.sprites():            opp.rect.center = (opp.rect.center[0] + 2, opp.rect.center[1])            if opp.rect.midright[0] > width + 20:                opp.kill()        # Updating sprite groups        clouds.update()        cloudsGroup2.update(speed=PlayerSpeed+3, minHeight=height * 2//3)        seagulls.update()        enemyGroup.update(tmpLvl.jumpForce, tmpLvl.gravity, projGroup)        projGroup.update()        p1.update(tmpLvl.jumpForce, tmpLvl.gravity)        # to cover glitchy sprites        screen.fill((0, 0, 0))        tmpLvl.rect.bottomleft = (int(index), int(bgBottomLeft))        if tmpLvl.bg != None:            screen.blit(tmpLvl.image, tmpLvl.rect)        else:            screen.fill(BG)        clouds.draw(screen)        decorations.update()        decorations.draw(screen)        healthBars.update(override=playerLives)        # Drawing all sprites to screen        projGroup.draw(screen)        enemyGroup.draw(screen)        all_sprites.draw(screen)        cloudsGroup2.draw(screen)        screen.blit(score1, score1Rect)        screen.blit(score2, score2Rect)        screen.blit(hs1.image, hs1.rect)        screen.blit(hs2.image, hs2.rect)        screen.blit(ps1, ps1Rect)        screen.blit(ps2, ps2Rect)        healthBars.draw(screen)        scanlineGroup.draw(screen)        # Refreshing screen        pygame.display.update()        if tmpLvl.zoomMode:            index -= 0.02            if bgBottomLeft < screen.get_height() * 2//3 + screen.get_height():                bgBottomLeft += 0.1            else:                bgBottomLeft -= 0.1        # Fixed Frame rate 110 recommended unless old computer        clock.tick(FPS)def multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object):    aliens = pygame.sprite.Group()    numberGroup = pygame.sprite.Group()    random.seed(datetime.now())    # Importing global variables    global PlayerSpeed    global CHANCE    PlayerSpeed = PlayerSpeed + 1    line = pygame.Surface((width, 20))    line.fill((0, 0, 0))    line.set_alpha(200)    lineRect = line.get_rect()    lineRect.topleft = (0, height * 1 // 2 - 10)    # Split-screen    sc1 = pygame.Surface((width, height / 2))    sc2 = pygame.Surface((width, height / 2))    # Splitscreen rect    sc1Rect = sc1.get_rect()    sc2Rect = sc2.get_rect()    # Positioning screens    sc1Rect.topleft = (0, 0)    sc2Rect.topleft = (0, height / 2)    tmplvl.loadBG(screen.get_size())    # defining players    p1 = Player(surf=sc1, AIMode=p1Mode, playerObject=p1Object, player1Bool=True)    players.add(p1)    p1Tag = PlayerTag(p1, "1")    p2 = Player(surf=sc2, AIMode=p2Mode, playerObject=p2Object, player1Bool=False)    players.add(p2)    p2Tag = PlayerTag(p2, "2")    numberGroup.add(p1Tag)    numberGroup.add(p2Tag)    # Defining ground platform    plat1 = Platform(True, 'platforms/' + tmplvl.platDir + '/' + tmplvl.startblock, None, sc1)    # Customizing platform    plat1.rect.topleft = (sc1.get_width() * 0.5, sc1.get_height() * 5 // 6 + 3)    plat2 = Platform(True, 'platforms/' + tmplvl.platDir + '/platform_0.png', None, sc1)    plat2.image = pygame.transform.scale(plat2.image, (plat2.image.get_width() * 2 // 3, plat2.image.get_width() * 2 // 3))    plat2.rect = plat2.image.get_rect()    plat2.rect.center = (sc1.get_width() * 1.15, sc1.get_height() * 9 // 12)    # Add initial platform to groups    platforms.add(plat1)    all_sprites.add(plat1)    platforms.add(plat2)    all_sprites.add(plat2)    # Creating font object    header = pygame.font.Font('fonts/segaArt.ttf', 100)    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    numberFont = pygame.font.Font("fonts/ka1.ttf", 150)    numbers = [        numberFont.render("3", BG2, (255, 55, 25)),        numberFont.render("2", BG2, (252, 186, 3)),        numberFont.render("1", BG2, (55, 255, 25)),        numberFont.render("GO!", BG2, (155, 255, 155))    ]    line1 = Text("Player 1 / " + p1.name + ": ", BG_FG_Color=(None, (150, 250, 150)), script=sub, pos=(0, 0))    line2 = Text("Player 2 / " + p2.name + ": ", BG_FG_Color=(None, (150, 250, 150)), script=sub, pos=(0, 0))    line1.rect.topleft = (0, 0)    line2.rect.topleft = line1.rect.bottomleft    started = False    ended = False    winner = None    counter = 0    platnum = 0    decor_plat = None    countVal = 500    index = 0    while True:        counter += PlayerSpeed        PlayerSpeed = int(PlayerSpeed)        # PlayerSpeed And Distance Text        ps1 = sub.render('Player Speed:', BG2, (55, 255, 55))        ps2 = sub.render(str(PlayerSpeed), BG2, (55, 55, 255))        pd1 = sub.render('Player Distance:', BG2, (55, 255, 55))        pd2 = sub.render(str(counter // FPS), BG2, (55, 55, 255))        # Win dialog        win = header.render('You Win', BG2, (55, 55, 255))        # Rectangle        ps1Rect = ps1.get_rect()        ps2Rect = ps2.get_rect()        pd1Rect = pd1.get_rect()        pd2Rect = pd1.get_rect()        winRect = win.get_rect()        # Position        ps1Rect.center = (width * 6 // 16, ps1.get_height() * 2)        ps2Rect.center = (width * 11 // 16, ps2.get_height() * 2)        pd1Rect.center = (width * 6 // 16, pd1.get_height() * 3)        pd2Rect.center = (width * 13 // 16, pd2.get_height() * 3)        winRect.center = (width / 2, height / 2)        # Window event handler        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        x, y = p1.rect.center        # Making the platforms move to create an illusion        # That the player is moving        for plat in platforms:            px, py = plat.rect.center            px -= PlayerSpeed            plat.rect.center = (px, py)        # Put in for loop for user to increase game intensity        for i in range(1):            new_plat = Platform(True, None, tmplvl.platDir, sc1)            new_plat.image = pygame.transform.scale(new_plat.image, (            new_plat.image.get_width() * 2 // 3, new_plat.image.get_height() * 2 // 3))            new_plat.rect = new_plat.image.get_rect()            new_plat.rect.center = (random.randrange(sc1.get_width() * 1.05, sc1.get_width() * 1.5), random.randrange(sc1.get_height() * 8 // 12, sc1.get_height() * 5 // 6))            # if platforms overlap            # remove them            if not pygame.sprite.spritecollide(new_plat, platforms, False):                platforms.add(new_plat)                all_sprites.add(new_plat)                platnum += 1                decor_plat = new_plat            else:                new_plat.kill()        if not ended and counter // FPS > 0:            for player in players.sprites():                x, y = player.rect.center                if y > sc1.get_height() * 2 or pygame.sprite.spritecollide(player, danger, False) or x < 0:                    delPlayer = player                    all_sprites.remove(delPlayer)                    players.remove(delPlayer)                    delPlayer.rect.bottomright = (0, 0)                    delPlayer.kill()                    break        if not ended:            if len(players.sprites()) < 2:                winner = players.sprites()[-1]                winner.AIMode = True                ended = True        else:            if PlayerSpeed > 2:                PlayerSpeed -= 0.07        # if platform is out of screen or if there are more than 10 platforms then destroy        i = 0        for plat in platforms:            i += 1            if plat.rect.topright[0] <= 0 or i > 10:                plat.kill()        # When players score divided by 100 gives a remainder of 0.        # And if player score is not zero its self        # In this case it's only used to increment the speed since this is a race.        if counter > 9000 and counter % (20 * 100) // tmplvl.factor == 0 and counter != 0:            alien = Seagull(tmplvl.platDir, sc1)            x, y = alien.rect.center            alien.rect.center = (x, random.randint(sc1.get_height() * 1 // 3, sc1.get_height() * 5 // 6))            if pygame.sprite.spritecollide(alien, aliens, False):                alien.kill()            else:                danger.add(alien)                aliens.add(alien)                all_sprites.add(alien)        if started:            if counter % (countVal) // tmplvl.factor == 0 and counter != 0:                PlayerSpeed += 1                countVal -= 50                if countVal <= 50:                    countVal = 250        # 1/chancenumber  = itself / 1.05        CHANCE //= 1.05        if platnum % 20 == 0 and platnum != 0:            new_decor = PlatDecorations(decor_plat, None, tmplvl.platDir)            if pygame.sprite.spritecollide(decor_plat, decorations, False):                new_decor.kill()            else:                decorations.add(new_decor)        for decor in decorations:            if decor.rect.midright[0] < 0 - screen.get_width() * 0.5:                decorations.remove(decor)                decor.kill()                break        for player in players.sprites():            player.update(tmplvl.jumpForce, tmplvl.gravity)        numberGroup.update()        decorations.update()        if started:            aliens.update()        sc1.fill((0, 0, 0))        sc2.fill((0, 0, 0))        sc1.blit(tmplvl.image1, tmplvl.rect1)        sc2.blit(tmplvl.image1, tmplvl.rect2)        decorations.draw(sc1)        decorations.draw(sc2)        sc1.blit(p1.image, p1.rect)        sc1.blit(p1Tag.image, p1Tag.rect)        sc2.blit(p2.image, p2.rect)        sc2.blit(p2Tag.image, p2Tag.rect)        # Drawing all sprites to screen        all_sprites.draw(sc1)        all_sprites.draw(sc2)        sc1.blit(line1.image, line1.rect)        sc2.blit(line2.image, line2.rect)        # Showing splitscreen        screen.blit(sc1, sc1Rect)        screen.blit(sc2, sc2Rect)        screen.blit(line, lineRect)        screen.blit(ps1, ps1Rect)        screen.blit(ps2, ps2Rect)        screen.blit(pd1, pd1Rect)        screen.blit(pd2, pd2Rect)        keys = pygame.key.get_pressed()        if keys[K_r]:            for sprite in decorations:                all_sprites.add(sprite)            ended = False            sleep(0.5)            for sprite in all_sprites:                sprite.kill()            CHANCE = 128            PlayerSpeed = PSD            multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object)            startScreen()        if ended:            for item in danger:                item.remove(danger)                item.remove(all_sprites)                item.kill()            if winner.name == p1Object.name:                win2 = sub.render("Player 1", BG2, (55, 155, 255))            if winner.name == p2Object.name:                win2 = sub.render("Player 2", BG2, (55, 155, 255))            win2Rect = win2.get_rect()            win2Rect.center = (width // 2, height * 2 // 3)            screen.blit(win2, win2Rect)            screen.blit(win, winRect)            for sprite in decorations:                all_sprites.add(sprite)            if keys[K_RETURN]:                ended = False                sleep(0.5)                for sprite in all_sprites:                    sprite.kill()                CHANCE = 128                PlayerSpeed = PSD                winner.kill()                winner = None                enterOpp()                startScreen()            if keys[K_r]:                ended = False                sleep(0.5)                for sprite in all_sprites:                    sprite.kill()                CHANCE = 128                PlayerSpeed = PSD                winner.kill()                winner = None                multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object)                startScreen()            if p1Pad != None or p2Pad != None:                if p1Pad.get_button(1):                    ended = False                    sleep(0.5)                    for sprite in all_sprites:                        sprite.kill()                    CHANCE = 128                    PlayerSpeed = PSD                    winner.kill()                    winner = None                    enterOpp()                    startScreen()                if p1Pad.get_button(9):                    ended = False                    sleep(0.5)                    for sprite in all_sprites:                        sprite.kill()                    CHANCE = 128                    PlayerSpeed = PSD                    winner.kill()                    winner = None                    multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object)                    startScreen()        if not started:            if index >= len(numbers) - 1:                PlayerSpeed = 6            else:                PlayerSpeed = 0            if pygame.sprite.spritecollideany(p1, platforms) or pygame.sprite.spritecollideany(p2, platforms):                if index >= len(numbers):                    index = 0                    started = True                    continue                tmpNum = numbers[int(index)]                numRect = tmpNum.get_rect()                numRect.center = (screen.get_width()//2, screen.get_height()//2)                screen.blit(tmpNum, numRect)                index += 0.01        scanlineGroup.draw(screen)        # Refreshing screen        pygame.display.update()        # Fixed Frame rate 110 recommended unless old computer        clock.tick(FPS)def helpScreen():    pygame.mixer.music.load('songs/help.ogg')    headerFont = pygame.font.Font('fonts/pixelart.ttf', 50)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    fontColor = (245, 245, 245)    Title = Text("Manual", (None, fontColor), headerFont, (0, 0))    Title.rect.topleft = (60, 30)    f = open("files/help.txt", "r")    fList = f.readlines()    f.close()    index = 0    firstLine = Text(fList[0],(None, fontColor), sub, (0, 0))    firstLine.rect.topleft = Title.rect.bottomleft    lines = [firstLine]    pygame.mixer.music.play(-1, 240)    for line in fList:        if line == firstLine:            continue        tmpLine = Text(line, (None, fontColor), sub, (0, 0))        tmpLine.rect.midtop = lines[index].rect.midbottom        lines.append(tmpLine)        index += 1    y = firstLine.rect.topleft[1]    gif_index = 0    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_DOWN]:                    if lines[0].rect.topleft[1] < Title.rect.bottomleft[1]:                        y += 20 * 5                if keys[K_UP]:                    if lines[-1].rect.bottomleft[1] > screen.get_height() * 2//3:                        y -= 20 * 5                if keys[K_ESCAPE]:                    enterOpp()                    startScreen()                    exit()        firstLine.rect.topleft = (firstLine.rect.topleft[0], y)        index = 0        for line in lines:            if line == firstLine:                continue            line.rect.midtop = lines[index].rect.midbottom            index += 1        if gif_index >= len(help_bg) - 1:            gif_index = 0        else:            gif_index += 1        screen.blit(help_bg[gif_index], (0, 0))        for line in lines:            screen.blit(line.image, line.rect)        screen.blit(Title.image, Title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def introScreen():    font = pygame.font.Font("fonts/segaArt.ttf", 125)    font2 = pygame.font.Font("fonts/pixelart.ttf", 125)    logo = font2.render("A2", None, (218, 235, 33))    logo2 = font.render(" Games", None, (218, 235, 33))    logoRect = logo.get_rect()    logo2Rect = logo2.get_rect()    logo2Rect.topleft = (width * 5 // 16, height / 2)    logoRect.topright = logo2Rect.topleft    i = 0    for i in range(255):        screen.fill((0, 0, 0))        screen.blit(logo, logoRect)        screen.blit(logo2, logo2Rect)        logo2.set_alpha(i)        logo.set_alpha(i)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)    sleep(0.5)    while i > 0:        screen.fill((0, 0, 0))        screen.blit(logo, logoRect)        screen.blit(logo2, logo2Rect)        logo.set_alpha(i)        logo2.set_alpha(i)        i -= 1        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)def enterOpp(surf=screen, font="fonts/headkick.ttf", msg=None, fadeOut=True, speed=1):    win = pygame.Surface(surf.get_size())    win.fill((0, 0, 0))    alphaVal = 0    script = pygame.font.Font(font, 50)    if msg != None:        mesg = Text(msg, (None, (255, 255, 255)), script, (screen.get_width()//2, screen.get_height()//2))    while alphaVal < 255:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()        if fadeOut:            pygame.mixer.music.set_volume(pygame.mixer.music.get_volume()-0.01)            if pygame.mixer.music.get_volume() < 0.03:                break        win.set_alpha(int(alphaVal))        screen.blit(win, (0, 0))        if msg != None:            screen.blit(mesg.image, mesg.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)        alphaVal += speed    pygame.mixer.music.set_volume(1)def startScreen():    COLOR = (245, 245, 245)    pygame.mixer.music.load('songs/startups/startup.ogg')    header1 = pygame.font.Font('fonts/pixelart.ttf', 75)    header2 = pygame.font.Font('fonts/pixelart.ttf', 50)    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    title = header2.render(name, BG2, COLOR)    cursor = sub.render('->', BG2, (100, 255, 100))    menuText = Text("Menu", (None, COLOR), header1)    start = Text("Start", (None, COLOR), sub)    help = Text("Help", (None, COLOR), sub)    indev = Text("Indev", (None, COLOR), sub)    exit = Text("Quit", (None, COLOR), sub)    titleRect = title.get_rect()    cursorRect = cursor.get_rect()    titleRect.center = (width/2, height * 1 // 2)    menuText.rect.center = (width//2, height//3)    options = [start, help, indev, exit]    for i in range(len(options)):        if i > 0:            options[i].rect.midtop = options[i-1].rect.midbottom        else:            options[i].rect.center = (width//2, height//2)    global multiBool    global firstEntry    pygame.mixer.music.play(-1)    global Exit    index = 0    opIndex = 0    while not Exit:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                Exit = True        if index >= len(startup_1) - 1:            index = 0            continue        else:            index += 1        bg = startup_1[index]        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(title, titleRect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)    titleRect.center = (width / 2, height * 1 // 3)    index = 0    shade = pygame.Surface(screen.get_size())    shade.fill((0, 0, 0))    shade.set_alpha(100)    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == KEYDOWN or event.type == pygame.JOYBUTTONDOWN or event.type == pygame.JOYAXISMOTION:                if event.key == K_DOWN:                    opIndex += 1                    break                if event.key == K_UP:                    opIndex -= 1                    break                if event.key == pygame.K_RETURN:                    enterOpp()                    for sprite in all_sprites:                        sprite.remove(all_sprites)                        sprite.kill()                    for sprite in danger:                        sprite.remove(danger)                        sprite.kill()                    if options[opIndex] == start:                        pygame.mixer.music.load("songs/level-select.ogg")                        pygame.mixer.music.play(-1)                        playerSelect()                        startScreen()                        sys.exit()                        break                    if options[opIndex] == exit:                        pygame.quit()                        sys.exit()                        break                    if options[opIndex] == help:                        helpScreen()                        startScreen()                        sys.exit()                        break                    if options[opIndex] == indev:                        pygame.mixer.music.load("songs/border-guard.ogg")                        pygame.mixer.music.play(-1)                        bossLevel(storymode_3[2], (playersList[2], False))                        startScreen()                        sys.exit()                        break        if index >= len(startup_2) - 1:            index = 0            continue        else:            index += 1        bg = startup_2[index]        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(shade, (0, 0))        if opIndex >= len(options):            opIndex = 0        if opIndex < 0:            opIndex = len(options) - 1        cursorRect.midright = options[opIndex].rect.midleft        for sprite in options:            screen.blit(sprite.image, sprite.rect)        screen.blit(cursor, cursorRect)        screen.blit(menuText.image, menuText.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def gameOver(player=None):    if player != None:        player.remove(players)        player.kill()    pygame.mixer.music.load('sounds/gameOver.ogg')    pygame.mixer.music.stop()    header = pygame.font.Font('fonts/pixelart.ttf', 40)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    text = header.render('Game Over', BG, (255, 255, 255))    text2 = sub.render('Press anything to continue', BG, (255, 255, 255))    textRect = text.get_rect()    text2Rect = text2.get_rect()    textRect.midbottom = (width // 2, height // 3)    text2Rect.midbottom = (width // 2, height * 3 // 6)    screen.blit(text, textRect)    screen.blit(text2, text2Rect)    pygame.mixer.music.play(0, 0)    pygame.display.flip()    while True:        for event in pygame.event.get():            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                sleep(0.25)                for sprite in all_sprites:                    sprite.kill()                    enterOpp()                    startScreen()                break            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        scanlineGroup.draw(screen)        pygame.display.flip()startScreen()