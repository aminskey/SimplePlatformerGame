# full importsimport pygame, sys, random, cv2# import specific methodsfrom pygame.locals import *from datetime import datetimefrom time import sleepfrom warnings import filterwarningsfrom os import listdirfrom os.path import isdirfrom sys import exit# filter warningfilterwarnings('ignore', category=DeprecationWarning)# initiate sound and graphicspygame.mixer.init()pygame.init()# Create FPS handlerclock = pygame.time.Clock()# Resolutionwidth = 900height = 700# joystickgameIcon = pygame.image.load("icons/gameIcon.png")pygame.display.set_icon(gameIcon)p1Pad = Nonep2Pad = Noneif pygame.joystick.get_count() > 0:    p1Pad = pygame.joystick.Joystick(0)    p1Pad.init()if pygame.joystick.get_count() > 1:    p2Pad = pygame.joystick.Joystick(0)    p2Pad.init()    p1Pad = pygame.joystick.Joystick(1)    p1Pad.init()# resolution tupleres = (width, height)firstEntry = True# Game namename = 'Sky Dash Adventures'subtitle = 'The Fight For Power'# Setting up windowscreen = pygame.display.set_mode(res, FULLSCREEN | SCALED)pygame.display.set_caption(name)# Sprite Groupsclouds = pygame.sprite.Group()platforms = pygame.sprite.Group()all_sprites = pygame.sprite.Group()danger = pygame.sprite.Group()players = pygame.sprite.Group()seagulls = pygame.sprite.Group()decorations = pygame.sprite.Group()scanlineGroup = pygame.sprite.Group()projGroup = pygame.sprite.Group()bossGroup = pygame.sprite.Group()# text and screen backgroundBG = (52, 164, 235)BG2 = (100, 100, 255)RED = (255, 0, 0)YELLOW = (255, 255, 0)BLUE = (0, 0, 255)GREEN = (0, 255, 0)BLACK = (0, 0, 0)WHITE = (255, 255, 255)# Invisible mousepygame.mouse.set_visible(False)# Initial Player speedPSD = 4# player speedPlayerSpeed = PSDMAXCHANCE = 64CHANCE = MAXCHANCE# e.g. CHANCE = 32 => 1/32 = 3.125% chance of lava blockFPS = 50# Calculating Players position relative to startvec = pygame.math.Vector2# extrasdebug = FalsescanlineBool = TruemultiBool = Falseended = False# for startscreenExit = FalsemaxSeqLen = 5# Clouds Classclass Clouds(pygame.sprite.Sprite):    # General settings    def __init__(self, pos, img="backgroundObjects/cloud.png", size=(150, 63), speed=2):        super().__init__()        self.image = pygame.image.load(img)        self.image = pygame.transform.scale(self.image, size)        self.rect = self.image.get_rect()        self.rect.center = pos        self.speed = speed    # Make them move in the air    def update(self, minHeight=0, speed=None):        x, y = self.rect.center        # if out of window then respawn ahead of widthspan        if x < -self.image.get_width() - 10:            random.seed(datetime.now())            x = width + self.image.get_width() + 10            y = random.randrange(minHeight, height)        # slowly drift backwards creating virtual effect        if speed == None:            x -= self.speed        else:            x -= speed        self.rect.center = (x, y)# platform classclass Platform(pygame.sprite.Sprite):    # initial settings    # asking Program if landable    def __init__(self, Landable, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        width, height = surface.get_size()        # if there is no specific image then use random        # if not landable then use lava block image.        if image == None:            plat_dir = listdir('platforms/' + dir)            bad_dir = listdir('badObjects/' + dir)            plat_max_len = len(plat_dir) - 1            bad_max_len = len(bad_dir) - 1            for item in plat_dir:                if isdir(item):                    plat_max_len -= 1            for item in bad_dir:                if isdir(item):                    bad_max_len -= 1            if Landable:                self.image = pygame.image.load(                    'platforms/' + dir + '/platform_' + str(random.randint(0, plat_max_len)) + '.png')            else:                self.image = pygame.image.load(                    'badObjects/' + dir + '/badplat' + str(random.randint(0, bad_max_len - 1)) + '.png')        else:            self.image = pygame.image.load(image)        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        # General settings        self.rect = self.image.get_rect()        self.rect.midleft = (width, random.randrange(height * 8 // 12, height * 5 // 6))        self.Landable = Landable        if not Landable:            self.rect.inflate_ip(-self.image.get_width()//4, -self.image.get_height()//4)    # self.pos = vec((self.rect.center))# Seagulls classclass Seagull(pygame.sprite.Sprite):    # initial settings    def __init__(self, dir="ground", surface=screen, image=None):        super().__init__()        width, height = surface.get_size()        if image == None:            self.image = pygame.image.load('badObjects/' + dir + '/air/seagull.png')        else:            self.image = pygame.image.load(image)        self.rect = self.image.get_rect()        self.rect.center = (random.randint(width, width * 2), random.randint(0, height * 5 // 24))        self.x, self.y = self.rect.center    # Update mechanism    def update(self):        self.x -= PlayerSpeed * 1.15        self.rect.center = (self.x, self.y)        if pygame.sprite.spritecollide(self, players, False):            self.image = pygame.image.load("misc/explosion.png")            self.rect = self.image.get_rect()            self.rect.center = (self.x, self.y)        # if seagull is out of screen then kill it        if self.rect.midright[0] < 0:            all_sprites.remove(self)            danger.remove(self)            seagulls.remove(self)            self.kill()class PlayerObject():    def __init__(self, name, sizeFactor, normalSize=False):        self.progress = return_progress(name)        self.name = name        self.normalSize = normalSize        if not multiBool:            self.sideLength = 40        else:            self.sideLength = 35        self.sizeFactor = sizeFactor        self.image = pygame.image.load("players/"+name+".png")    def progress_update(self):        self.progress = return_progress(self.name)class Projectile(pygame.sprite.Sprite):    def __init__(self, pos, image="misc/fireball.png", size=1, direction=1, soundeffect=None):        super().__init__()        self.image = pygame.image.load(image)        self.image = pygame.transform.scale(self.image, (self.image.get_width()*size, self.image.get_height()*size))        self.rect = self.image.get_rect()        self.sender = None        self.rect.center = pos        self.pos = pos        self.damage = 0.05        self.counter = 0        self.max = 25        self.direction = direction        if soundeffect:            pygame.mixer.Sound(soundeffect).play()    def update(self):        self.counter += float(abs(self.direction))        self.rect.centerx += self.image.get_width()//2 * self.direction        if self.counter >= self.max:            self.remove(projGroup)            self.kill()# Player classclass Player(pygame.sprite.Sprite):    # initial settings    def __init__(self, playerObject, AIMode=False, surf=screen, player1Bool=True, raceMode=False, bossMode=False):        super().__init__()        self.sideLength = playerObject.sideLength        # Temporary variable only used inside __init__ method        sizeFactor = playerObject.sizeFactor        self.image = playerObject.image        if not playerObject.normalSize:            self.image = pygame.transform.scale(self.image, (self.sideLength // sizeFactor, self.sideLength // sizeFactor))        self.blownup = pygame.image.load("misc/explosion.png")        self.rect = self.image.get_rect()        self.rect.center = (width // 2, 0)        self.health = 3        self.InBossFight = False        self.acc = 0        self.relpos = vec(self.rect.center)        self.name = playerObject.name        self.jumpstate = True        self.dead = False        self.AIMode = AIMode        self.jumpGame = False        self.IsBoss = bossMode        self.moveBools = [False, False]        if self.AIMode:            self.jumpstate = False        self.vel = 0        self.prevVel = 0        self.rectify_pos = False        # Can use powerups True|False        self.powerUpBool = True        self.powerUps = []        self.player1Bool = player1Bool        self.fric = -0.30        self.screen = surf        self.raceBool = raceMode        self.raceSpeed = random.randint(1, 3)        self.canMove = True        # Variables that make the sprite compatible with boss levels. In this case the sprite is the boss        self.damage = 0        self.delay = 100        self.fuel = 10        self.refill = False        self.regjump = True        self.enemy = None        self.destructive_enemy = False        self.maxCD = 2        self.cooldown = 10        if self.IsBoss:            self.rect.bottomleft = screen.get_rect().topleft            self.jumpstate = False    def fire(self):        proj = Projectile((self.rect.midright[0] + 20, self.rect.midright[1]))        proj.sender = self        proj.add(projGroup)        if self.IsBoss:            proj.add(danger)    def race(self, keys):        if self.rect.centerx <= width * 11//12:            if self.player1Bool:                if keys[K_RIGHT]:                    self.rect.centerx += 2                if keys[K_LEFT]:                    self.rect.centerx -= 2            else:                if keys[K_d]:                    self.vel += 2                if keys[K_a]:                    self.vel -= 2    def move(self, keys):        if self.player1Bool:            if keys[K_RIGHT]:                self.vel += PSD//4            if keys[K_LEFT]:                self.vel -= PSD//4        else:            if keys[K_d]:                self.vel += PSD//4            if keys[K_a]:                self.vel -= PSD//4        if self.vel >= PSD * 3:            self.vel = PSD * 3        elif self.vel <= -PSD * 3:            self.vel = -PSD * 3        if self.rect.midright[0] > width * 5//6:            # self.rect.midright = (width * 5//6, self.rect.midright[1])            self.rect.midright = (self.rect.midright[0] + self.vel, self.rect.midright[1])            # self.vel -= 1        elif self.rect.midleft[0] < width//6:            # self.rect.midleft = (width//6, self.rect.midleft[1])            self.rect.midleft = (self.rect.midleft[0] + self.vel, self.rect.midleft[1])            # self.vel += 1        else:            if self.vel != 0:                self.prevVel = self.vel            if self.vel < 0:                self.rect.centerx += self.vel - self.fric            if self.vel > 0:                self.rect.centerx += self.vel + self.fric            self.moveBools = [False, False]        if pygame.sprite.spritecollideany(self, platforms):            if self.vel < 0:                self.vel -= self.fric            if self.vel > 0:                self.vel += self.fric    # Jump mechanism    def jump(self, keys, jumpForce=20):        x, y = self.rect.center        # Event handling        if not self.AIMode and not self.IsBoss:            if self.player1Bool:                if keys[K_SPACE]:                    # jumping                    y -= jumpForce            else:                if keys[K_w]:                    y -= jumpForce            if p1Pad != None:                if p1Pad.get_button(0):                    y -= jumpForce        else:            y -= jumpForce        # Updating position        self.rect.center = (x, y)    def bossProg(self):        dist = self.rect.centerx - self.enemy.rect.centerx        self.jumpstate = False        if self.rect.midleft[0] >= 0 and self.rect.midright[0] <= width:            # Check if number negative or not            if abs(dist) <= 250:                if isNegative(dist) and abs(dist) >= 150:                    if not self.refill:                        if self.cooldown <= 0:                            self.fire()                            self.fuel -= 1                            self.cooldown = self.maxCD                        else:                            self.cooldown -= 1.5                    else:                        self.fuel += 1                else:                    if pygame.sprite.spritecollideany(self.enemy, platforms):                        self.rect.centerx -= self.raceSpeed                        self.jumpstate = True                    else:                        self.jumpstate = False                        self.acc -= 0.01            else:                self.rect.centerx -= int((dist+1)/abs(dist+1)) * self.raceSpeed            if self.fuel <= 0:                self.refill = True            elif self.fuel >= 10:                self.refill = False        else:            self.rect.centerx -= int((self.rect.centerx - width//2)/abs((self.rect.centerx - width//2))) * self.raceSpeed        if pygame.sprite.spritecollideany(self, projGroup):            pygame.sprite.spritecollideany(self, projGroup).kill()            self.health -= 0.01            self.jumpstate = True    def AI(self):        if width * 4 // 6 >= self.rect.centerx > width // 6:            if self.raceBool and self.canMove:                oppGroup = pygame.sprite.Group()                oppGroup.add(self.enemy)                if pygame.sprite.spritecollideany(self, oppGroup):                    if not self.destructive_enemy:                        if self.jumpstate:                            self.jumpstate = False                        else:                            self.jumpstate = True                    else:                         self.enemy.health -= 1                    self.rect.centerx -= 5                if self.enemy.rect.centerx > self.rect.centerx - 100 or self.enemy.rect.centerx < self.rect.centerx + 100:                    self.rect.centerx += self.raceSpeed                else:                    self.rect.centerx += self.raceSpeed * 2        else:            self.canMove = False        if self.rect.centerx <= width * 3 // 6:            self.canMove = True        if pygame.sprite.spritecollideany(self, projGroup):            self.jumpstate = True            if self.rect.centerx > width//3:                self.rect.centerx -= 8        elif pygame.sprite.spritecollideany(self, platforms):            self.jumpstate = False            if self.raceBool:                if self.rect.centerx < self.enemy.rect.centerx - 50:                    self.fire()            collided_platform = pygame.sprite.spritecollide(self, platforms, False)[-1]            next_platform = None            # Calculate index number for collided platform            index = 0            for plat in platforms.sprites():                if plat == collided_platform:                    try:                        next_platform = platforms.sprites()[index + 1]                        break                    except IndexError:                        next_platform = platforms.sprites()[index]                    break                index += 1            distance = (next_platform.rect.midleft[0] - collided_platform.rect.midright[0])            if distance <= 80 and self.rect.centery <= collided_platform.rect.midtop[0]:                self.jumpstate = False            elif distance <= 200 and self.rect.centery <= collided_platform.rect.midtop[0]:                if self.rect.y <= 10:                    self.jumpstate = False            elif self.rect.centerx >= collided_platform.rect.midright[0] or self.rect.centery >= collided_platform.rect.midtop[1]:                self.jumpstate = True    # Gravity mechanics    def gravity(self, gravityDecimal=0.5):        x, y = self.rect.center        # checking for collision        # If not then continue falling and updating position        if not pygame.sprite.spritecollide(self, platforms, False):            y += self.acc            self.acc += gravityDecimal            self.rect.center = (x, y)        # else stop and update position        else:            self.acc = 0            self.rect.center = (x, y)    # The Update mechanism    def update(self, jumpForce=10, gravity=0.5, otherGroup=danger, sender=None):        x, y = self.rect.midtop        keys = pygame.key.get_pressed()        # Updating Position        self.rect.midtop = (x, y)        if pygame.sprite.spritecollideany(self, platforms):            currPlat = pygame.sprite.spritecollide(self, platforms, False)[-1]            self.jumpstate = True            if self.rect.midtop[1] < currPlat.rect.midtop[1] and self.rect.centery > currPlat.rect.midtop[1]:                self.rect.centery = currPlat.rect.midtop[1]            elif self.rect.midtop[1] > currPlat.rect.midtop[1]:                if self.rect.centerx > currPlat.rect.midleft[0] and self.rect.centerx < currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midleft[0]                elif self.rect.centerx < currPlat.rect.midright[0] and self.rect.centerx > currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midright[0]        # Updating relative position        self.relpos.x += PlayerSpeed        if self.jumpGame:            self.move(keys)        if self.race and not self.AIMode:            self.race(keys)        if self.AIMode:            self.AI()        elif self.IsBoss:            self.bossProg()        else:            if keys[K_x]:                sleep(0.005)                self.fire()        # If not in air allow jump mechanism        if self.jumpstate:            self.jump(keys, jumpForce)        # Running virtual gravity method        self.gravity(gravity)        if not self.regjump and self.IsBoss:            self.jumpstate = False        if pygame.sprite.spritecollide(self, otherGroup, False):            if self.health <= 0:                self.image = pygame.image.load("misc/explosion.png")                self.image = pygame.transform.scale(self.image, (100, 100))                self.rect = self.image.get_rect()                self.rect.midtop = (x, y)                if self.rect.midright[0] >= 0:                    self.rect.centerx -= 1                else:                    self.kill()            else:                if not self.IsBoss:                    self.health -= 0.1                self.jumpstate = True        if pygame.sprite.spritecollideany(self, projGroup):            proj = pygame.sprite.spritecollideany(self, projGroup)            if otherGroup.has(proj.sender) or proj.sender == self.enemy:                self.health -= 0.1                proj.kill()class Boss(pygame.sprite.Sprite):    def __init__(self, name, fuel, delay=100):        super().__init__()        self.name = name        self.neutral = self.return_state_image("neutral")        self.blownup = pygame.transform.scale(pygame.image.load("misc/explosion.png"), (self.neutral.get_width(), self.neutral.get_width()))        self.image = self.neutral        self.rect = self.image.get_rect()        self.health = 9        self.acc_y = 0        self.max_gravity_acceleration = 10        self.jumpstate = False        self.enemy = None  # Sprite object        self.fuel = fuel        self.damage = 1.5        self.delay = delay        self.boundaries = [            screen.get_width()//6,            screen.get_width()//2,            screen.get_width()        ]        self.counter = 0    def gravity(self, acceleration=0.5):        self.rect.centery += self.acc_y        if self.acc_y < self.max_gravity_acceleration:            self.acc_y += acceleration    def jump(self, force=10):        if not self.jumpstate:            self.acc_y = -force            self.jumpstate = True    def return_state_image(self, state):        state = pygame.image.load("bosses/" + self.name + "/" + self.name + "-" + state + ".png")        return state    def fire(self, image="misc/fireball.png", direction=1, size=1, pos=(0, 0), max=5, soundeffect=None):        pygame.mixer.Sound(soundeffect).play()        proj = Projectile(pos, image, size, direction)        proj.sender = self        proj.max = max        projGroup.add(proj)        danger.add(proj)        self.fuel -= 1    def update(self):        if pygame.sprite.spritecollideany(self, projGroup):            proj = pygame.sprite.spritecollideany(self, projGroup)            if players.has(proj.sender):                self.health -= self.damage                pygame.mixer.Sound("sounds/pop.wav").play()        if self.health <= 0:            self.image = pygame.transform.scale(pygame.image.load("misc/explosion.png"), res)class Guard_01(Boss):    def __init__(self):        super().__init__("B-01", 1, 500)        self.up_img = self.return_state_image("up")        self.down_img = self.return_state_image("down")        self.small_img = self.return_state_image("small")        self.entrance_mode = True        self.speed = 6        self.rect.topright = (0, 0)        self.full = True        self.max_delay = 15        self.shot_delay = self.max_delay        self.damage = 0.025        self.health = 9        self.counter = 0        self.dist = None        self.started_playing = False        self.sounds = [            pygame.mixer.Sound("sounds/jet-1.wav"),            pygame.mixer.Sound("sounds/jet-2.wav")        ]        for sound in self.sounds:            sound.play()    def entrance(self):            if self.rect.midleft[0] > screen.get_width():                self.rect.center = (screen.get_width()*3, screen.get_height()//2)                self.entrance_mode = False            self.rect.centerx += self.speed * 4    def AI(self):        # shooting range        self.dist = (self.rect.midleft[0] - (self.enemy.rect.centerx), self.rect.midleft[1] - self.enemy.rect.centery)        if self.full:            self.counter = 0            if self.dist[0] <= 500 and self.dist[0] >= 50:                if self.rect.centery < self.enemy.rect.centery - 50:                    self.rect.centery += self.speed                if self.rect.centery > self.enemy.rect.centery - 50:                    self.rect.centery -= self.speed                if abs(self.dist[1]) < 200:                    if self.shot_delay <= 0:                        self.fire("misc/lazer.png", -0.2, 3, (self.rect.midleft[0] + 10, self.rect.midleft[1] - 50), max=20, soundeffect="sounds/lazer_fire.wav")                        self.shot_delay = self.max_delay                    else:                        self.shot_delay -= 0.55            else:                if self.dist[0] < 50:                    self.rect.x += self.speed * 2                else:                    self.rect.x -= self.speed * 2        else:            if self.counter == 0:                snd = pygame.mixer.Sound("sounds/charge.wav")                snd.play()            else:                if self.rect.topleft[1] > 0:                    self.rect.centery -= 1                if self.rect.topright[0] > width:                    self.rect.centerx -= 2            self.counter += 1    def update(self):        if not self.full:            if self.fuel <= 10:                self.fuel += 0.015            else:                self.full = True        if self.fuel <= 0:            self.full = False        if self.entrance_mode:            self.entrance()        else:            self.AI()        if self.health <= 0:            for sound in self.sounds:                sound.stop()        super().update()class Rampager(Boss):    def __init__(self):        super().__init__("rampager", 20)        self.boost_image = self.return_state_image("boost")        self.rect.midright = screen.get_rect().midleft    def AI(self):        if self.fuel >= 0:            self.image = self.neutral            if self.rect.midright[0] < self.enemy.rect.midleft[0] - 150:                self.rect.centerx += 2            else:                if self.rect.midleft[0] < screen.get_width():                    if self.enemy.rect.centerx > self.rect.midright[0]:                        sleep(0.00005)                        self.fire(size=10, pos=self.rect.midright, soundeffect="sounds/flame.wav")                else:                    self.rect.centerx -= 2        else:            self.boost()            if self.fuel < 150:                self.fuel += 0.0025            elif self.health < 5:                self.fire(size=10, pos=self.rect.midright, soundeffect="sounds/flame.wav")    def boost(self):        if self.image == self.neutral:            self.image = self.boost_image            self.rect.midright = self.rect.center        self.rect.centerx += 5    def update(self):        if not pygame.sprite.spritecollideany(self, platforms):            self.gravity()        else:            plat = pygame.sprite.spritecollideany(self, platforms)            if self.rect.centery >= plat.rect.midtop[1]:                self.jumpstate = False        self.AI()        self.jump()        self.rect.centerx -= 1        super().update()class PlatDecorations(pygame.sprite.Sprite):    def __init__(self, platform, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        self.ok = True        if image != None:            self.image = pygame.image.load(image)        else:            decor_max_len = len(listdir('decorations/' + dir)) - 1            self.image = pygame.image.load(                'decorations/' + dir + '/decor_' + str(random.randint(0, decor_max_len)) + '.png')        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        if platform == None:            print("Cannot summon decoration, specified platform is None")            self.ok = False        self.rect = self.image.get_rect()        self.platform = platform        self.surface = surface    def update(self):        self.rect.midbottom = self.platform.rect.midtop        if self.rect.center[0] < 0:            self.kill()class PlayerTag(pygame.sprite.Sprite):    def __init__(self, player, number):        super().__init__()        font = pygame.font.Font("fonts/pixelart.ttf", 40)        self.image = font.render(number, BG2, (55, 255, 55))        self.num = number        self.player = player        self.rect = self.image.get_rect()        self.rect.midbottom = self.player.rect.midtop    def update(self):        self.rect.midbottom = self.player.rect.midtop        if not self.player:            self.kill()# Levels Classclass Level():    def __init__(self, bg, spriteDirs, song, startblock, factor=1, playerStartSpeed=PSD, moveBool=False, gravity=0.5, jumpForce=20, name="Unknown Level", diff="easy", zoomMode=False, boss=None, acc=1):        self.bg = bg        self.factor = factor        self.diff = diff        self.name = name        self.acc = acc        self.zoomMode = zoomMode        if self.bg != None:            self.noBG = False            self.bg = "backgrounds/" + bg        else:            self.noBG = True            self.bg = "backgrounds/Unknown.png"        self.bgSong = song        self.length = 2500        self.fl = 2000        self.platDir, self.cloud = spriteDirs        self.jumpForce = jumpForce        self.gravity = gravity        self.psd = playerStartSpeed        self.moveBool = moveBool        self.startblock = startblock        self.boss = boss    def loadBG(self, res):        self.image = pygame.image.load(self.bg)        if self.zoomMode:            self.image = pygame.transform.scale(self.image, (res[0]*2, res[1]*2)).convert()        else:            self.image = pygame.transform.scale(self.image, res)        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, res[1])class Line(pygame.sprite.Sprite):    def __init__(self, thickness, alpha, color, pos, length=screen.get_width()):        super().__init__()        self.alpha = alpha        self.image = pygame.Surface((length, thickness))        self.image.fill(color)        self.image.set_alpha(self.alpha)        self.rect = self.image.get_rect()        self.rect.topleft = posclass Text(pygame.sprite.Sprite):    def __init__(self, str, BG_FG_Color, script, pos=(0,0)):        super().__init__()        self.msg = str        self.image = script.render(str, BG_FG_Color[0], BG_FG_Color[1])        self.rect = self.image.get_rect()        self.rect.center = posclass HealthBar(pygame.sprite.Sprite):    def __init__(self, player, surf, dir_name="healthbars"):        super().__init__()        self.images = [            pygame.image.load(dir_name+"/bar0.png"),            pygame.image.load(dir_name+"/bar1.png"),            pygame.image.load(dir_name+"/bar2.png"),            pygame.image.load(dir_name+"/bar3.png")        ]        self.image = self.images[-1]        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, surf.get_height())        self.player = player    def update(self, override=None):        if not override:            self.image = self.images[int(self.player.health)]        else:            self.image = self.images[int(override)]class PlayerCard(pygame.sprite.Sprite):    def __init__(self, player, customIMG=None, customName=None):        super().__init__()        self.image = pygame.Surface((screen.get_width()//3, screen.get_height() * 9//12))        self.rect = self.image.get_rect()        self.image.fill((0, 0, 0))        self.image.set_alpha(200)        if not customIMG:            self.player_img = pygame.transform.scale(player.image, (self.image.get_width() * 5//6, self.image.get_width() * 5//6))        else:            self.player_img = pygame.transform.scale(customIMG, (self.image.get_width() * 5 // 6, self.image.get_width() * 5 // 6))        self.player_rect = self.player_img.get_rect()        self.player_rect.topleft = (self.image.get_width() * 1//12, self.image.get_width() * 1//12)        tmp_font = pygame.font.Font("fonts/pixelart.ttf", 50)        big_font = pygame.font.Font("fonts/pixelart.ttf", 100)        if not customName:            self.name = player.name        else:            self.name = customName        self.player = player        self.name_obj = Text(player.name, (None, (155, 155, 155)), tmp_font)        self.name_obj.image.set_alpha(200)        self.name_obj.rect.center = (self.image.get_width()//2, self.image.get_height()*5//6)        self.progress_count = self.player.progress        self.progress = int((self.progress_count/len(storymodes[self.name]))*100)        self.progress_img = Text(str(f"{self.progress}%"), (None, GREEN), big_font, (self.image.get_width() // 2, self.player_rect.midbottom[1] + (self.name_obj.rect.centery - self.player_rect.midbottom[1]) // 2))        self.image.blit(self.player_img, self.player_rect)        self.image.blit(self.progress_img.image, self.progress_img.rect)        self.image.blit(self.name_obj.image, self.name_obj.rect)class Rect_Surf(pygame.sprite.Sprite):    def __init__(self, size=(10,20), color=(255,25,25), rot=0):        super().__init__()        self.image = pygame.transform.rotate(pygame.Surface(size), rot)        self.rect = self.image.get_rect()        self.image.fill(color)        self.move_coords = (0, 0)        self.move_bool = False        self.step = [0, 0]def return_attributes(tag):    with open("players/.playerdata", "rb") as f:        lines = f.readlines()        f.close()    data = []    reading = False    end_tag = "--end--"    for line in lines:        line = line.strip().decode()        if line == tag:            reading = True            continue        elif line == end_tag:            break        if reading:            data.append(line)    return datadef return_progress(name):    player_data = return_attributes("# Levels Completed")    for player in player_data:        data = player.split(': ')        if data[0] == name:            print(int(data[1]))            return int(data[1])def update_progress(player, progress):    with open("players/.playerdata", "rb") as f:        lines = f.readlines()        f.close()    with open("players/.playerdata", "wb") as f:        for line in lines:            if line.strip().decode().split(': ')[0] == player:                f.write((player + ": " + str(progress) + "\n").encode())            else:                f.write(line)        f.close()mars_level1 = Level("dual-BGs/mars-dual1.png", ("space", None), "round-2.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Mars Orbit", zoomMode=True, acc=0.5)mars_level2 = Level("mars.png", ("sand", None), "round-2.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5)jp = 10grav = 0.3playersList = [    PlayerObject("stingray", 1),    PlayerObject("wasp", 1)]enemy = PlayerObject("enemy-big", 1, True)enemy2 = PlayerObject("enemy_2", 1)antagonist = PlayerObject("red", 1)green_player = PlayerObject("green", 1)fmv_images = ["FMV/Temple.png", "FMV/City.png", "FMV/Crystal.png", "FMV/City-2.png", "players/red.png", "backgrounds/earth-orbit.png", "FMV/Hero.png"]title_sound = pygame.mixer.Sound("sounds/title_sound.ogg")#Stingraystorymode_1 = [    Level("nebula.png", ("neon", None), "nebula.ogg", "platform_4.png", 10, 11, False, 0.25, 15, "Somewhere", zoomMode=True),    Level("planet-orbit.png", ("neon", "cloud.png"), "planet-orbit.ogg", "platform_4.png", 10, 1, False, 1.2, 20, "Chill Clouds", acc=0.5),    Level("jungle.png", ("jungle", None), "jungle.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "Jungle Islands", zoomMode=True),    Level("wayout.png", ("jungle", None), "wayout.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "Near The Edge", zoomMode=True),    Level("uranus.png", ("space", None), "neptune.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Uranus"),    Level("uranus.png", ("space", None), "border-guard.ogg", "platform_5.png", 10, 11, False, grav, jp, "Border Guard", boss=Guard_01),    Level("wormhole.png", ("space", None), "wormhole.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Wormhole", zoomMode=True, acc=0.75),    mars_level1,    Level("dual-BGs/mars-dual1.png", ("space", None), "battle-bg2.ogg", "platform_0.png", 10, 11, False, grav, jp, "Mars", zoomMode=True, acc=0.5, boss=Player(playersList[1], bossMode=True, player1Bool=False))]#Waspstorymode_2 = [    Level("galaxy.png", ("space", None), "galaxy.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Outside The Milky Way", zoomMode=False),    Level("pluto.png", ("space", None), "pluto.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Pluto", zoomMode=True),    Level("neptune.png", ("space", None), "neptune.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Neptune"),    Level("unknown.png", ("neon", None), "vgm-2.ogg", "platform_1.png", 10, 11, False, 0.7, 15, "Abandoned Ship", zoomMode=True),    Level("ganymede.png", ("space", None), "nebula.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Ganymede", acc=0.75),    Level("exoplanet.png", ("jungle", "cloud.png"), "vgm.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "Ocean Moon", acc=0.25),    Level("exoplanet.png", ("jungle", None), "boss-fight.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "The Rampager", boss=Rampager),    Level("jupiter.png", ("space", None), "round-1.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Jupiter", acc=1.5),    Level("asteroid-belt.png", ("space", None), "big_asteroid.ogg", "platform_5.png", 10, 10, False, 0.5, 10, "Asteroid Belt"),    Level("asteroid.png", ("space", None), "big_asteroid.ogg", "platform_5.png", 10, 15, False, 0.5, 10, "Big Comet", zoomMode=True),    mars_level1,    Level("dual-BGs/mars-dual1.png", ("space", None), "battle-bg2.ogg", "platform_0.png", 10, 11, False, grav, jp, "Mars", zoomMode=True, acc=0.5, boss=Player(playersList[0], bossMode=True, player1Bool=False))]storymode_3 = [    Level("earth-orbit.png", ("space", None), "earth-orbit.ogg", "platform_5.png", 10, 11, False, 0.3, 7, "Earth Orbit"),    Level("metro-city.png", ("space", None), "round-2.ogg", "platform_5.png", 10, 11, False, 0.3, 7, "The Crust"),    Level("earth-core.png", ("space", None), "round-1.ogg", "platform_5.png", 10, 11, False, 0.3, 7, "Earth\'s Core"),    Level("crystal.png", ("space", None), "earth.ogg", "platform_5.png", 10, 11, False, 0.3, 7, "The Crystal")]storymodes = {    "stingray" : storymode_1,    "wasp" : storymode_2,    "green" : storymode_3}def scanlines(thickness):    if scanlineBool:        for i in range(screen.get_height()):            if i % (thickness * 4) == 0:                tmp_line = Line(thickness, 100, (0, 0, 0), (0, i))                tmp_line.image.set_alpha(100)                scanlineGroup.add(tmp_line)scanlines(1)def isNegative(num):    return num < 0def returnFrames(src, size, transparency=False):    slides = cv2.VideoCapture(src)    imageList = []    while True:        ret, frame = slides.read()        if not ret:            break        shape = frame.shape[1::-1]        img = pygame.image.frombuffer(frame.tobytes(), shape, "BGR").convert_alpha()        img = pygame.transform.scale(img, size)        if transparency:            img.set_colorkey((255, 255, 255))        imageList.append(img)    slides.release()    return imageListloading = pygame.image.load("backgrounds/loading.png")loading = pygame.transform.scale(loading, res)screen.blit(loading, (0, 0))pygame.display.update()lvlSelect_Anim = returnFrames("backgrounds/levelSelect.gif", res)startup_1 = returnFrames("backgrounds/startup-1.gif", res)startup_2 = returnFrames("backgrounds/startup-2.gif", res)help_bg = returnFrames("backgrounds/help.gif", res)easter_egg = returnFrames("backgrounds/levelSelect-2.gif", res)boss_alert = returnFrames("backgrounds/red_alert.gif", res)enemyFreq = [1, 10]dummy1 = [playersList[0], True]dummy2 = [enemy2, True]mainPlayer = Nonedef grpFight(level, p1, list):    bossGroup.empty()    for sprite in list:        sprite.enemy = p1        bossGroup.add(sprite)        print(sprite)    bossLevel(level, p1)def bossLevel(level, player1):    pygame.mixer.music.load("songs/" + level.bgSong)    pygame.mixer.music.play(-1)    healthbarGroup = pygame.sprite.Group()    textGroup = pygame.sprite.Group()    monitorGroup = pygame.sprite.Group()    for item in danger:        item.remove(projGroup)        item.remove(danger)        item.kill()    for player in players.sprites():        player.remove(players)        player.kill()    for boss in bossGroup.sprites():        boss.remove(bossGroup)        boss.kill()    for item in platforms.sprites():        item.remove(platforms)        item.remove(all_sprites)        item.kill()    if type(level.boss) is not type:        level_boss = level.boss    else:        level_boss = level.boss()    player1.InBossFight = True    player1.enemy = level_boss.enemy    level_boss.enemy = player1    level.loadBG(res)    level.rect.bottomleft = screen.get_rect().bottomleft    level.image.set_alpha(100)    players.add(player1)    bossGroup.add(level_boss)    danger.add(level_boss)    plat1 = Platform(True, image="platforms/" + level.platDir + "/" + level.startblock)    plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 2, plat1.image.get_height() * 2))    plat1.rect = plat1.image.get_rect()    plat1.rect.midleft = (width//2, screen.get_height() * 10/12)    main_y_coord = plat1.rect.midtop[1]    tmp_plat = Platform(True, image="platforms/" + level.platDir + "/" + level.startblock)    tmp_plat.rect.midleft = plat1.rect.midright    platforms.add(plat1)    platforms.add(tmp_plat)    player1.rect.midbottom = plat1.rect.midtop    font = pygame.font.Font("fonts/segaArt.ttf", 85)    sub = pygame.font.Font("fonts/ka1.ttf", 50)    name_font = pygame.font.Font("fonts/ka1.ttf", 35)    p1Healthbar = HealthBar(player1, screen)    bossBar = HealthBar(level_boss, screen)    healthbarGroup.add(p1Healthbar)    healthbarGroup.add(bossBar)    p1Healthbar.rect.topleft = (0, 0)    player1.raceBool = True    p1Name = Text(player1.name, (None, WHITE), name_font)    p1Name.rect.topleft = p1Healthbar.rect.bottomleft    bossName = Text(level_boss.name, (None, WHITE), name_font)    bossName.rect.bottomright = screen.get_rect().bottomright    bossBar.rect.bottomright = bossName.rect.topright    textGroup.add(p1Name)    textGroup.add(bossName)    speed = 1    ended = False    color = GREEN    p1Wins = Text("Boss Defeated", (None, color), font, (screen.get_width() // 2, screen.get_height() // 3))    p2Wins = Text("You Lose", (None, color), font, (screen.get_width() // 2, screen.get_height() // 3))    msg = Text("Press \'ESC\' to continue", (None, WHITE), sub, (screen.get_width()//2, screen.get_height() * 2//3))    finalWin = None    acc = 0.1    counter = 0    loss = False    shadow = None    loser = None    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_ESCAPE and ended:                    enterOpp()                    if loss:                        startScreen()                        exit()                    else:                        return        for player in players.sprites():            if not ended:                player.rect.centerx -= 1                if player.rect.centery > height or player.rect.midright[0] < 0 or player.rect.midleft[0] > width:                    player.health = 0        if not ended:            if speed <= 200:                speed += acc        else:            if speed > 10:                speed -= 0.3            else:                speed = 10        for plat in platforms:            plat.rect.centerx -= int(speed)            if plat.rect.midright[0] < -15:                plat.remove(platforms)                plat.kill()        for i in range(10):            new_plat = Platform(True, dir=level.platDir)            new_plat.rect.midtop = (new_plat.rect.centerx, main_y_coord)            if pygame.sprite.spritecollideany(new_plat, platforms):                new_plat.kill()            else:                new_plat.add(platforms)        if not ended:            if level_boss.health <= 0:                ended = True                finalWin = p1Wins                level_boss.image = level_boss.blownup                loser = level_boss            if player1.health <= 0:                ended = True                loss = True                finalWin = p2Wins                player1.image = player1.blownup                loser = player1        else:            loser.rect.x -= 2            if not shadow:                shadow = Text(finalWin.msg, (None, BLACK), font)                shadow.rect.topleft = (finalWin.rect.topleft[0] + 5, finalWin.rect.topleft[1] + 5)            textGroup.add(shadow)            textGroup.add(finalWin)            textGroup.add(msg)        if len(projGroup.sprites()) >= 2:            proj = projGroup.sprites()[-1]            if pygame.sprite.spritecollideany(proj, projGroup).sender != proj.sender:                opp = pygame.sprite.spritecollideany(proj, projGroup)                opp.remove(projGroup)                opp.kill()                proj.remove(projGroup)                proj.kill()        players.update(level.jumpForce, level.gravity)        projGroup.update()        if level_boss.health <= 3:            healthbarGroup.update()        else:            p1Healthbar.update()            bossBar.update(override=level_boss.health//3)        monitorGroup.update()        screen.blit(level.image, level.rect)        players.draw(screen)        projGroup.draw(screen)        if (counter//FPS) >= level_boss.delay and not ended:            bossGroup.update()        bossGroup.draw(screen)        platforms.draw(screen)        healthbarGroup.draw(screen)        textGroup.draw(screen)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)        counter += speeddef levelSelect(list, lvlSelect_Anim=easter_egg):    font = pygame.font.Font("fonts/pixelart.ttf", 20)    fontColor = (64, 125, 120)    levelMenu = pygame.Surface((screen.get_width() * 2 // 3, screen.get_height()))    menuRect = levelMenu.get_rect()    menuRect.topleft = (screen.get_width() // 3, 0)    cursor = font.render(">", BG2, (55, 255, 55))    cursorRect = cursor.get_rect()    cursorRect.topleft = (0, 0)    prevWin = pygame.Surface((screen.get_width() // 3 - 20, screen.get_height() // 4))    prevRect = prevWin.get_rect()    prevRect.topleft = (10, screen.get_height() // 4)    win1 = pygame.Surface((screen.get_width()//3, screen.get_height()))    win2 = pygame.Surface((win1.get_width(), win1.get_height()))    win1.fill((0, 0, 0))    win2.fill((0, 0, 0))    win1Rect = win1.get_rect()    win2Rect = win2.get_rect()    win1Rect.topleft = (0, 0)    win2Rect.topright = (screen.get_width(), 0)    win1Prev = pygame.Surface((160, 160))    win2Prev = pygame.Surface((win1Prev.get_width(), win1Prev.get_height()))    prev1Rect = win1Prev.get_rect()    prev2Rect = win2Prev.get_rect()    prev1Rect.center = win1Rect.center    prev2Rect.center = win2Rect.center    lineList = []    bgList = []    diffList = []    i = 0    for level in list:        tmp = font.render(level.name, BG2, fontColor)        tmpRect = tmp.get_rect()        tmpRect.topleft = (20, i * tmp.get_height() + 5)        diff = font.render(level.diff, BG2, (152, 32, 32))        diffRect = diff.get_rect()        lineList.append((tmp, tmpRect, level))        diffList.append((diff, diffRect))        image = pygame.image.load(level.bg)        image = pygame.transform.scale(image, prevWin.get_size())        rect = image.get_rect()        rect.topleft = (0, 0)        bgList.append((image, rect))        i += 1    # clear rubish from screen    screen.fill((0, 0, 0))    itr = 0    run = True    index = 0    while run:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_UP]:                    if itr <= 0:                        itr = len(lineList) - 1                    else:                        itr -= 1                    break                if keys[K_DOWN]:                    if itr >= len(lineList) - 1:                        itr = 0                    else:                        itr += 1                    break                if keys[K_RETURN]:                    return itr                if keys[K_ESCAPE]:                    enterOpp()                    startScreen()                    break        tmp, lnRect, level = lineList[itr]        bgImage, bgRect = bgList[itr]        diff, diffRect = diffList[itr]        diffRect.topleft = prevRect.bottomleft        cursorRect.midright = lnRect.midleft        if index >= len(lvlSelect_Anim) - 1:           index = 0           continue        else:           index += 1        bg = lvlSelect_Anim[int(index)]        screen.blit(bg, (0, 0))        levelMenu.fill((0, 0, 0))        levelMenu.set_alpha(150)        prevWin.blit(bgImage, bgRect)        screen.blit(diff, diffRect)        for line in lineList:            lineIMG, lineRect, tmp = line            levelMenu.blit(lineIMG, lineRect)        levelMenu.blit(cursor, cursorRect)        screen.blit(levelMenu, menuRect)        screen.blit(prevWin, prevRect)        scanlineGroup.draw(prevWin)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(25)def lvlalert(level):    font = pygame.font.Font("fonts/BEYONDCONTROL.ttf", 45)    title = Text(level.name, (None, (255,255,255)), font)    title.rect.midleft = screen.get_rect().midright    obj1 = Rect_Surf((screen.get_width()//4, screen.get_height() * 15//16), RED)    obj2 = Rect_Surf((screen.get_width() * 7//8, screen.get_height()//4), YELLOW)    print(obj1)    print(obj2)    obj1.rect.midbottom = (screen.get_width()//4, 0)    obj2.rect.midleft = (screen.get_width(), screen.get_height() * 3//4)    title.rect.midright = (0, screen.get_height()//3)    level.loadBG(screen.get_size())    i = 0    FPS = 50    alpha_val = 0    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()        if (i//FPS) <= 1.5:            if obj1.rect.midtop[1] < 0:                obj1.rect.centery += 10            if obj2.rect.center[0] > screen.get_width() * 1//2:                obj2.rect.centerx -= 10            if title.rect.center[0] < screen.get_width() * 1//2 + 20:                title.rect.centerx += 10        else:            if obj1.rect.midtop[1] <= screen.get_height():                obj1.rect.centery += 15            if obj2.rect.midright[0] > 0:                obj2.rect.centerx -= 15            if title.rect.midleft[0] <= screen.get_width():                title.rect.centerx += 15            alpha_val += 7        if alpha_val >= 255:            return         level.image.set_alpha(alpha_val)        screen.fill(BLUE)        screen.blit(level.image, level.rect)        screen.blit(obj1.image, obj1.rect)        screen.blit(obj2.image, obj2.rect)        screen.blit(title.image, title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)        i += 1def playerSelect():    cards = []    hidden_storymode = False    for item in playersList:        item.progress_update()        cards.append(PlayerCard(item))    if cards[0].progress == 100 and cards[1].progress == 100:        hidden_storymode = True        cards.clear()        cards = [PlayerCard(green_player)]    title = Text("Select Character", (None, (255, 255, 50)), pygame.font.Font("fonts/headkick.ttf", 75))    title.rect.midtop = screen.get_rect().midtop    if not hidden_storymode:        cards[0].rect.midtop = (cards[0].image.get_width() * 3//4, title.rect.midbottom[1])        cards[1].rect.midtop = (width - cards[0].image.get_width()* 3//4, title.rect.midbottom[1])    else:        cards[0].rect.midtop = (width//2, title.rect.midbottom[1])    global CHANCE    global mainPlayer    playerIndex = 0    gifIndex = 0    keys_pressed = []    codePass = False    sequence = [K_SPACE, K_UP, K_DOWN, K_a, K_s]    running = True    i = 0    while running:        cursor_1 = Text(">" + cards[playerIndex].name + " selected<", (None, (0, 255, 0)), pygame.font.Font("fonts/pixelart.ttf", 30))        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYUP:                keys_pressed.append(event.key)                break            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_LEFT:                    playerIndex -= 1                    break                if event.key == pygame.K_RIGHT:                    playerIndex += 1                    break                if event.key == pygame.K_ESCAPE:                    enterOpp()                    startScreen()                    break                if event.key == pygame.K_RETURN:                    i = return_progress(cards[playerIndex].name)                    if i < len(storymodes[cards[playerIndex].name]):                        running = False                        break                    else:                        pygame.mixer.Sound("sounds/opp.wav").play()        if not codePass:            if len(keys_pressed) >= maxSeqLen:                for i in range(maxSeqLen):                    if not keys_pressed[-i] == sequence[-i]:                        codePass = False                        keys_pressed.clear()                        break                    else:                        codePass = True        gifIndex += 1        if gifIndex >= len(lvlSelect_Anim):            gifIndex = 0        bg = lvlSelect_Anim[gifIndex]        if playerIndex >= len(cards):            playerIndex = 0        if playerIndex < 0:            playerIndex = len(cards) - 1        cursor_1.rect.midtop = cards[playerIndex].rect.midbottom        screen.blit(bg, (0, 0))        screen.blit(title.image, title.rect)        for item in cards:            screen.blit(item.image, item.rect)        screen.blit(cursor_1.image, cursor_1.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)    # Actual Gameplay    while i < len(storymodes[cards[playerIndex].name]):        mainPlayer = Player(cards[playerIndex].player)        if codePass:            enterOpp()            pygame.mixer.music.stop()            pygame.mixer.music.unload()            pygame.mixer.music.load("songs/easter_egg.ogg")            pygame.mixer.music.play(-1)            i = levelSelect(storymodes[mainPlayer.name])            codePass = False        CHANCE = MAXCHANCE        item = storymodes[mainPlayer.name][i]        pygame.mixer.music.stop()        pygame.mixer.music.unload()        if item.boss:            # Check if item.boss is a tuple            if type(item.boss) is tuple:                grpFight(item, mainPlayer, item.boss)            else:                incoming_boss()                bossLevel(item, mainPlayer)        else:            main(item, p1=mainPlayer)        i += 1        cards[playerIndex].player.progress = i        update_progress(cards[playerIndex].name, i)    enterOpp()def incoming_boss():    gifIndex = 0    pygame.mixer.music.load("sounds/boss_alert.ogg")    pygame.mixer.music.play(-1)    for i in range(100):        gifIndex += 1        if gifIndex >= len(boss_alert):            gifIndex = 0        bg = boss_alert[gifIndex]        screen.blit(bg, (0, 0))        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(10)    enterOpp()def main(level, p1=None, playerSpeed=0, playerLives=3):    for plat in platforms:        plat.remove(all_sprites)        plat.remove(platforms)        plat.kill()    for item in danger:        item.remove(danger)        item.remove(all_sprites)        item.remove(platforms)        item.kill()    for item in decorations:        item.remove(all_sprites)        item.remove(decorations)        item.kill()    for item in clouds:        item.remove(all_sprites)        item.remove(clouds)        item.kill()    for item in danger:        item.remove(all_sprites)        item.remove(danger)        item.kill()    players.empty()    all_sprites.empty()    screen.fill((0, 0, 0))    pygame.display.update()    p1.raceBool = True    enemyGroup = pygame.sprite.Group()    healthBars = pygame.sprite.Group()    if level.noBG:        level.bg = None    if level.bg != None:        level.loadBG(res)    MTLength = level.length    cloudsGroup2 = pygame.sprite.Group()    # Creating background clouds    if level.cloud != None:        for i in range(15):            new_cloud = Clouds((random.randrange(0, width), random.randrange(0, height)), "backgroundObjects/" + level.cloud)            if i > 20:                new_cloud.image.set_alpha(220)                new_cloud.speed = 2                clouds.add(new_cloud)            else:                new_cloud.speed = 1                new_cloud.image.set_alpha(165)                if not pygame.sprite.spritecollide(new_cloud, clouds, False):                    clouds.add(new_cloud)        for i in range(5):            new_cloud = Clouds((random.randrange(0, width), random.randrange(height * 2//3, height)), "backgroundObjects/" + level.cloud, size=(225, 95))            new_cloud.image.set_alpha(128)            if not pygame.sprite.spritecollideany(new_cloud, cloudsGroup2):                cloudsGroup2.add(new_cloud)    # Importing global variables    global PlayerSpeed    global CHANCE    global enemyFreq    if playerSpeed == 0:        PlayerSpeed = level.psd    else:        PlayerSpeed = playerSpeed    # defining player    if p1 == None:        p1 = Player(playersList[0])    all_sprites.add(p1)    players.add(p1)    # Defining ground platform    plat1 = Platform(True, "platforms/" + level.platDir + '/' + level.startblock)    # Customizing platform    plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 3, plat1.image.get_height() * 3))    plat1.rect = plat1.image.get_rect()    plat1.rect.topleft = (50, height * 5 // 6 + 3)    plat2 = Platform(True, "platforms/" + level.platDir + '/platform_0.png')    plat2.rect.center = (width * 1.25, height * 4 // 6)    # Add initial platform to groups    platforms.add(plat1)    all_sprites.add(plat1)    platforms.add(plat2)    all_sprites.add(plat2)    # loop the background music    pygame.mixer.music.load("songs/" + level.bgSong)    pygame.mixer.music.play(-1)    lvlalert(level)    platnum = 0    # Creating font object    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    index = 0    if level.zoomMode:        bgBottomLeft = level.rect.bottomleft[1] + 50    else:        bgBottomLeft = level.rect.bottomleft[1]    countVal = 250    checkMode = False    intensity = 1    p1_liveBar = HealthBar(p1, screen, "lives")    p1_healthbar = HealthBar(p1, screen)    p1_liveBar.rect.bottomleft = p1_healthbar.rect.topleft    healthBars.add(p1_liveBar)    healthBars.add(p1_healthbar)    fightmode = False    done = False    title = pygame.font.Font("fonts/ka1.ttf", 75)    zone_finished = Text("Zone Complete", (BG2, (150, 150, 150)), title, screen.get_rect().center)    finished_shadow = Text("Zone Complete", (BG2, (0, 0, 0)), title, (width//2 + 5, height//2 + 5))    msg = Text("Press Enter", (BG2, (255, 0, 0)), sub, (width//2, height//2 + 80))    msg_shadow = Text("Press Enter", (BG2, (0, 0, 0)), sub, (width // 2 + 3, height // 2 + 83))    run = True    iterator = 0    p1.raceSpeed = 3    dist_bar = pygame.image.load("dist_sprites/dist-bar.png")    bar_rect = dist_bar.get_rect()    dist_needle = pygame.image.load("dist_sprites/dist-needle.png")    ndl_rect = dist_needle.get_rect()    bar_rect.midtop = screen.get_rect().midtop    ndl_rect.topleft = bar_rect.topleft    big_font = pygame.font.Font("fonts/Ledsim.ttf", 200)    while run:        iterator += 1        player_dist = int(p1.relpos.x // FPS)        speed_txt = Text(str(int(PlayerSpeed)), (None, (0, 255, 0)), big_font, (screen.get_width() * 5//6, screen.get_height() * 5//6))        speed_shdw = Text(str(int(PlayerSpeed)), (None, (0, 0, 0)), big_font, (speed_txt.rect.centerx + 5, speed_txt.rect.centery + 5))        if not done:            dist_pct = player_dist/MTLength            ndl_rect.topleft = (int(bar_rect.topleft[0]+((dist_bar.get_width()-3)*dist_pct)), 5)        # Window event handler        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_RETURN and done:                    pygame.mixer.music.stop()                    run = False                    p1.AIMode = False                    break                if event.key == pygame.K_9:                    p1.relpos.x = 2000*FPS                    fightmode = True                    break                if event.key == pygame.K_8:                    p1.relpos.x = (level.fl-1000)*FPS                    fightmode = False                    break        # Making the platforms move to create an illusion        # That the player is moving        for plat in platforms:            plat.rect.centerx -= PlayerSpeed        if iterator % 5 == 0:            for i in range(2):                #random.seed(datetime.now())                choice = random.randint(0, int(CHANCE))                new_plat = None                if choice == 0:                    if not fightmode:                        new_plat = Platform(False, None, level.platDir)                        danger.add(new_plat)                else:                    if fightmode:                        new_plat = Platform(True, "platforms/" + level.platDir + "/" + level.startblock)                        new_plat.rect.midleft = (platforms.sprites()[-1].rect.midright[0], screen.get_height() * 5//6)                    else:                        new_plat = Platform(True, None, level.platDir)                    platnum += 1                # if platforms overlap                # remove them                if new_plat:                    if pygame.sprite.spritecollideany(new_plat, platforms) and not fightmode:                        new_plat.kill()                    else:                        platforms.add(new_plat)                        all_sprites.add(new_plat)                        if platnum % 5 == 0 and new_plat.Landable:                            new_decor = PlatDecorations(new_plat, None, level.platDir)                            decorations.add(new_decor)        if (player_dist) > level.fl:            fightmode = True            p1.raceBool = True        # checking if the player died        # If it happened then reset settings and run gameOver method        if not done:            if p1.rect.centery > height * 3//2 or pygame.sprite.spritecollide(p1, danger, False) or p1.rect.midright[0] < 0 or p1.health <= 0:                playerLives -= 1                if playerLives <= 0:                    PlayerSpeed = level.psd                    CHANCE = MAXCHANCE                    for item in decorations:                        all_sprites.add(item)                    for item in clouds:                        item.remove(clouds)                        item.kill()                    for plat in platforms:                        plat.remove(all_sprites)                        plat.remove(platforms)                        plat.kill()                    gameOver(p1)                else:                    p1.health=3                    pygame.mixer.music.pause()                    PlayerSpeed = 6                    p1.acc = 0                    p1.rect.midtop = screen.get_rect().midtop                    pygame.mixer.Sound("sounds/pop.wav").play()                    sleep(0.5)                    for item in seagulls.sprites():                        item.remove(seagulls)                        item.kill()                    for item in projGroup.sprites():                        item.remove(projGroup)                        item.kill()                    enterOpp()                    pygame.mixer.music.set_pos(0.0)                    pygame.mixer.music.unpause()                    lvlalert(level)        # if platform is out of screen or if there are more than 10 platforms then destroy        i = 0        for plat in platforms:            i += 1            if plat.rect.midright[0] < 0:                plat.kill()        # Seagull spawning after player distance 50000/FPS Rate        if (player_dist) > 1500:            # Chance of a seagull spawning            choice = random.randint(0, CHANCE)            # If true then spawn            if choice == 0:                for i in range(random.randrange(0, 3)):                    new_seagull = Seagull(level.platDir)                    if not pygame.sprite.spritecollide(new_seagull, seagulls, False):                        seagulls.add(new_seagull)                        all_sprites.add(new_seagull)                        danger.add(new_seagull)        if (player_dist) > MTLength and player_dist != 0:            if not done:                enterOpp(bgColor=(255, 255, 255), speed=3)                pygame.mixer.music.unload()                pygame.mixer.music.load("songs/complete-2.ogg")                pygame.mixer.music.play()                p1.AIMode = True                done = True            if done:                if PlayerSpeed < 120:                    PlayerSpeed += 0.05        # When players score divided by factor number gives a remainder of 0.        # And if player score not zero its self        countVal -= 0.0025        if countVal < 25:            countVal = 300        if not done and iterator % 11 == 0:            if p1.relpos.x % (countVal) // level.factor == 0 and p1.relpos.x != 0:                PlayerSpeed += level.acc                if (player_dist) > 50:                    if CHANCE > MAXCHANCE//4:                        CHANCE //= 1.0005        if fightmode and not done:            if (player_dist) > level.fl and iterator % 200 == 0:                tmp = Player(enemy2, True)                tmp.rect.midright = (-20, screen.get_height() * 2//3)                tmp.AIMode = True                tmp.enemy = p1                p1.enemy = tmp                tmp.raceBool = True                tmp.player1Bool = False                tmp.health = 0.5                tmp.regjump = False                tmp.raceSpeed = 5                enemyGroup.add(tmp)        else:            if len(enemyGroup.sprites()) > 0:                for sprite in enemyGroup.sprites():                    sprite.remove(enemyGroup)                    sprite.kill()        if p1.relpos.x % (countVal * 10) // level.factor == 0 and p1.relpos.x < 0:            intensity += 1        while len(enemyGroup.sprites()) > 10:            tmp = enemyGroup.sprites()[-1]            tmp.remove(enemyGroup)            tmp.kill()        # If player is too far out then push it in the middle.        if p1.rect.centerx < width//3 or p1.rect.centerx > width * 2//3:            checkMode = True        if checkMode:            if p1.rect.centerx < width//2:                p1.rect.centerx += 1            elif p1.rect.centerx > width//2:                p1.rect.centerx -= 1            else:                checkMode = False        for opp in enemyGroup.sprites():            opp.rect.center = (opp.rect.center[0] + 2, opp.rect.center[1])            if opp.rect.midright[0] > width + 20:                opp.kill()        # Updating sprite groups        clouds.update()        cloudsGroup2.update(speed=(PlayerSpeed+3), minHeight=height * 2//3)        seagulls.update()        enemyGroup.update(level.jumpForce, level.gravity, projGroup)        projGroup.update()        p1.update(level.jumpForce, level.gravity, otherGroup=projGroup)        level.rect.bottomleft = (int(index), int(bgBottomLeft))        if level.bg != None:            if done:                level.image.set_alpha(25)            screen.blit(level.image, level.rect)        else:            screen.fill(BG)        clouds.draw(screen)        decorations.update()        decorations.draw(screen)        p1_liveBar.update(playerLives)        p1_healthbar.update()        # Drawing all sprites to screen        projGroup.draw(screen)        enemyGroup.draw(screen)        #danger.draw(screen)        all_sprites.draw(screen)        cloudsGroup2.draw(screen)        screen.blit(dist_bar, bar_rect)        screen.blit(dist_needle, ndl_rect)        screen.blit(speed_shdw.image, speed_shdw.rect)        screen.blit(speed_txt.image, speed_txt.rect)        if done:            screen.blit(finished_shadow.image, finished_shadow.rect)            screen.blit(msg_shadow.image, msg_shadow.rect)            screen.blit(zone_finished.image, zone_finished.rect)            screen.blit(msg.image, msg.rect)        healthBars.draw(screen)        scanlineGroup.draw(screen)        if level.zoomMode:            index -= 0.02            if bgBottomLeft < screen.get_height() * 2 // 3 + screen.get_height():                bgBottomLeft += 0.1            else:                bgBottomLeft -= 0.1        # Refreshing screen        pygame.display.update()        clock.tick(FPS)def helpScreen():    pygame.mixer.music.load('songs/help.ogg')    headerFont = pygame.font.Font('fonts/pixelart.ttf', 50)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    fontColor = (245, 245, 245)    Title = Text("Manual", (None, fontColor), headerFont, (0, 0))    Title.rect.topleft = (60, 30)    f = open("files/help.txt", "r")    fList = f.readlines()    f.close()    index = 0    firstLine = Text(fList[0],(None, fontColor), sub, (0, 0))    firstLine.rect.topleft = Title.rect.bottomleft    lines = [firstLine]    pygame.mixer.music.play(-1)    for line in fList:        if line == firstLine:            continue        tmpLine = Text(line, (None, fontColor), sub, (0, 0))        tmpLine.rect.midtop = lines[index].rect.midbottom        lines.append(tmpLine)        index += 1    y = firstLine.rect.topleft[1]    gif_index = 0    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_DOWN]:                    if lines[0].rect.topleft[1] < Title.rect.bottomleft[1]:                        y += 20 * 5                if keys[K_UP]:                    if lines[-1].rect.bottomleft[1] > screen.get_height() * 2//3:                        y -= 20 * 5                if keys[K_ESCAPE]:                    enterOpp()                    startScreen()                    exit()        firstLine.rect.topleft = (firstLine.rect.topleft[0], y)        index = 0        for line in lines:            if line == firstLine:                continue            line.rect.midtop = lines[index].rect.midbottom            index += 1        if gif_index >= len(help_bg) - 1:            gif_index = 0        else:            gif_index += 1        screen.blit(help_bg[gif_index], (0, 0))        for line in lines:            screen.blit(line.image, line.rect)        screen.blit(Title.image, Title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def introScreen():    font = pygame.font.Font("fonts/BEYONDCONTROL.ttf", 25)    sk_logo = pygame.image.load("icons/gameIcon.png")    hd_quality = pygame.image.load("icons/hd-quality.png")    sk_rect = sk_logo.get_rect()    q_rect = hd_quality.get_rect()    sk_rect.center = screen.get_rect().center    q_rect.center = screen.get_rect().center    text = Text("For Best Experience Use Headphones", (None, (255, 255, 255)), font)    text.rect.midtop = q_rect.midbottom    i = 0    while i < 255:        sk_logo.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(sk_logo, sk_rect)        pygame.display.update()        clock.tick(60)        i += 1    sleep(0.5)    while i > 0:        sk_logo.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(sk_logo, sk_rect)        pygame.display.update()        clock.tick(60)        i -= 1    i = 0    while i < 255:        hd_quality.set_alpha(i)        text.image.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(hd_quality, q_rect)        screen.blit(text.image, text.rect)        pygame.display.update()        clock.tick(60)        i += 1    sleep(0.5)    while i > 0:        hd_quality.set_alpha(i)        text.image.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(hd_quality, q_rect)        screen.blit(text.image, text.rect)        pygame.display.update()        clock.tick(60)        i -= 1def enterOpp(surf=screen, font="fonts/headkick.ttf", msg=None, fadeOut=True, speed=1, bgColor=(0, 0, 0), textColor=(255, 255, 255), size=50):    win = pygame.Surface(surf.get_size())    win.fill(bgColor)    alphaVal = 0    script = pygame.font.Font(font, size)    if msg != None:        mesg = Text(msg, (None, textColor), script, (screen.get_width()//2, screen.get_height()//2))    while alphaVal < 255:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()        if fadeOut:            pygame.mixer.music.set_volume(pygame.mixer.music.get_volume()-0.01)            if pygame.mixer.music.get_volume() < 0.03:                break        win.set_alpha(int(alphaVal))        screen.blit(win, (0, 0))        if msg != None:            screen.blit(mesg.image, mesg.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)        alphaVal += speed    pygame.mixer.music.set_volume(1)def textrollScreen(file="prologue.txt", col=(255, 255, 255), fnt="fonts/pixelart.ttf", size=50):    pygame.mixer.music.stop()    pygame.mixer.music.load("songs/startups/intro.ogg")    pygame.mixer.music.set_volume(0.25)    pygame.mixer.music.play()    pic = []    mount = (width//2, height//3)    for bg in fmv_images:        img = pygame.transform.scale(pygame.image.load(bg), (width * 3//4, height//3))        pic.append(img)    rect = pic[0].get_rect()    rect.center = mount    with open(f"files/{file}", "rb") as f:        buff = f.read().decode()        f.close()    segments = buff.replace('\r\n', '').split('::')    font = pygame.font.Font(fnt, size)    lineGrp = []    timer = 0    index = 0    alphaVal = 1    bgAlpha = 1    inc_bgAlpha = 1    inc = 2    picIndex = 0    i = 0    for seg in segments:        parag = seg.split('<<nl<<')        print(f"{seg}: {parag}")        tmpArr = []        for line in parag:            tmpArr.append(Text(line, (None, col), font))        i += 1        lineGrp.append(tmpArr)    while index < len(lineGrp):        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == KEYDOWN and debug:                pygame.mixer.music.stop()                return        if picIndex > len(pic) - 1:            picIndex = 0        bg = pic[picIndex]        bg.set_alpha(bgAlpha)        screen.fill(BLACK)        screen.blit(bg, rect)        for line in lineGrp[index]:            line.image.set_alpha(alphaVal)            line.rect.center = (screen.get_rect().centerx, lineGrp[index].index(line) * size + height * 7//12)            screen.blit(line.image, line.rect)        if timer % 255 == 0 and timer > 0:            index += 1        if timer % 510 == 0 and timer > 0:            picIndex += 1        if alphaVal >= 255 or alphaVal <= 0:            inc *= -1        if bgAlpha >= 255 or bgAlpha <= 0:            inc_bgAlpha *= -1        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)        timer += 1        alphaVal += inc        bgAlpha += inc_bgAlphadef startScreen():    COLOR = (245, 245, 245)    pygame.mixer.music.load('songs/startups/startup.ogg')    header1 = pygame.font.Font('fonts/pixelart.ttf', 50)    header2 = pygame.font.Font('fonts/pixelart.ttf', 35)    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    title = header1.render(name, BG2, COLOR)    sub_title = Text(subtitle, (None, COLOR), header2)    cursor = sub.render('->', BG2, (100, 255, 100))    menuText = Text("Menu", (None, COLOR), header1)    start = Text("Start", (None, COLOR), sub)    help = Text("Help", (None, COLOR), sub)    indev = Text("Indev", (None, COLOR), sub)    reset = Text("Reset Data", (None, COLOR), sub)    exit = Text("Quit", (None, COLOR), sub)    playerData_headers = ["wasp", "stingray", "green", "intro"]    titleRect = title.get_rect()    cursorRect = cursor.get_rect()    titleRect.center = (width/2, height * 1 // 2)    menuText.rect.center = (width//2, height//3)    sub_title.rect.midtop = titleRect.midbottom    options = [start, help, indev, reset, exit]    for i in range(len(options)):        if i > 0:            options[i].rect.midtop = options[i-1].rect.midbottom        else:            options[i].rect.center = (width//2, height//2)    global multiBool    global firstEntry    pygame.mixer.music.play(-1)    global Exit    index = 0    opIndex = 0    while not Exit:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                Exit = True        if index >= len(startup_1) - 1:            index = 0            continue        else:            index += 1        bg = startup_1[index]        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(title, titleRect)        screen.blit(sub_title.image, sub_title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)    titleRect.center = (width / 2, height * 1 // 3)    index = 0    shade = pygame.Surface(screen.get_size())    shade.fill((0, 0, 0))    shade.set_alpha(100)    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == KEYDOWN or event.type == pygame.JOYBUTTONDOWN or event.type == pygame.JOYAXISMOTION:                if event.key == K_DOWN:                    opIndex += 1                    break                if event.key == K_UP:                    opIndex -= 1                    break                if event.key == pygame.K_RETURN:                    enterOpp()                    for sprite in all_sprites:                        sprite.remove(all_sprites)                        sprite.kill()                    for sprite in danger:                        sprite.remove(danger)                        sprite.kill()                    if options[opIndex] == start:                        pygame.mixer.music.load("songs/level-select.ogg")                        pygame.mixer.music.play(-1)                        playerSelect()                        startScreen()                        sys.exit()                        break                    if options[opIndex] == exit:                        pygame.quit()                        sys.exit()                        break                    if options[opIndex] == help:                        helpScreen()                        startScreen()                        sys.exit()                        break                    if options[opIndex] == indev:                        textrollScreen()                        enterOpp()                        title_sound.play()                        enterOpp(font="fonts/pixelart.ttf", msg="SKY DASH", fadeOut=False, size=150)                        enterOpp()                        startScreen()                        sys.exit()                        break                    if options[opIndex] == reset:                        pygame.mixer.music.stop()                        enterOpp()                        for data in playerData_headers:                            update_progress(data, 0)                        Exit = False                        enterOpp(font="fonts/segaArt.ttf", msg="Reset Complete", fadeOut=False)                        startScreen()                        sys.exit()        if index >= len(startup_2) - 1:            index = 0            continue        else:            index += 1        bg = startup_2[index]        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(shade, (0, 0))        if opIndex >= len(options):            opIndex = 0        if opIndex < 0:            opIndex = len(options) - 1        cursorRect.midright = options[opIndex].rect.midleft        for sprite in options:            screen.blit(sprite.image, sprite.rect)        screen.blit(cursor, cursorRect)        screen.blit(menuText.image, menuText.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def gameOver(player=None):    if player != None:        player.remove(players)        player.kill()    pygame.mixer.music.load('sounds/gameOver.ogg')    pygame.mixer.music.stop()    header = pygame.font.Font('fonts/pixelart.ttf', 40)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    text = header.render('Game Over', BG, (255, 255, 255))    text2 = sub.render('Press anything to continue', BG, (255, 255, 255))    textRect = text.get_rect()    text2Rect = text2.get_rect()    textRect.midbottom = (width // 2, height // 3)    text2Rect.midbottom = (width // 2, height * 3 // 6)    screen.blit(text, textRect)    screen.blit(text2, text2Rect)    pygame.mixer.music.play(0, 0)    pygame.display.flip()    while True:        for event in pygame.event.get():            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                sleep(0.25)                for sprite in all_sprites:                    sprite.kill()                    enterOpp()                    startScreen()                break            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        scanlineGroup.draw(screen)        pygame.display.flip()if not debug:    introScreen()    if return_progress("intro") == 0:        textrollScreen()        enterOpp()        title_sound.play()        enterOpp(font="fonts/pixelart.ttf", msg="SKY DASH", fadeOut=False, size=150)        enterOpp()        update_progress("intro", 1)startScreen()