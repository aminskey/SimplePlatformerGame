# full importsimport pygame, sys, random, cv2# import specific methodsfrom pygame.locals import *from datetime import datetimefrom time import sleep, timefrom warnings import filterwarningsfrom os import listdirfrom os.path import isdir# filter warningfilterwarnings('ignore', category=DeprecationWarning)# initiate sound and graphicspygame.mixer.init()pygame.init()# Create FPS handlerclock = pygame.time.Clock()# Resolutionwidth = 900height = 700# joystickgameIcon = pygame.image.load("icons/gameIcon.png")pygame.display.set_icon(gameIcon)p1Pad = Nonep2Pad = Noneif pygame.joystick.get_count() > 0:    p1Pad = pygame.joystick.Joystick(0)    p1Pad.init()if pygame.joystick.get_count() > 1:    p2Pad = pygame.joystick.Joystick(0)    p2Pad.init()    p1Pad = pygame.joystick.Joystick(1)    p1Pad.init()# resolution tupleres = (width, height)firstEntry = True# Game namename = 'Sky Dash Battle'# Setting up windowscreen = pygame.display.set_mode(res)pygame.display.set_caption(name)# Sprite Groupsclouds = pygame.sprite.Group()platforms = pygame.sprite.Group()all_sprites = pygame.sprite.Group()danger = pygame.sprite.Group()players = pygame.sprite.Group()seagulls = pygame.sprite.Group()decorations = pygame.sprite.Group()scanlineGroup = pygame.sprite.Group()projGroup = pygame.sprite.Group()# text and screen backgroundBG = (52, 164, 235)BG2 = (100, 100, 255)# Invisible mousepygame.mouse.set_visible(False)# Initial Player speedPSD = 4# player speedPlayerSpeed = PSDCHANCE = 64# 1/32 = 3.125% chance of lava blockFPS = 50rounds = 0# Highscore variablehighscore = 0# Calculating Players position relative to startvec = pygame.math.Vector2# extrasdebug = TruescanlineBool = FalsemultiBool = Falseended = FalsearcadeLSelect = TruebonusUnlocked = True# for startscreenExit = False# Clouds Classclass Clouds(pygame.sprite.Sprite):    # General settings    def __init__(self, pos, img="backgroundObjects/cloud.png", size=(150, 63), speed=1):        super().__init__()        self.image = pygame.image.load(img)        self.image = pygame.transform.scale(self.image, size)        self.rect = self.image.get_rect()        self.rect.center = pos        self.speed = speed    # Make them move in the air    def update(self, minHeight=0, speed=None):        x, y = self.rect.center        # if out of window then respawn ahead of widthspan        if x < -self.image.get_width() - 10:            random.seed(datetime.now())            x = width + self.image.get_width() + 10            y = random.randrange(minHeight, height)        # slowly drift backwards creating virtual effect        if speed == None:            x -= self.speed        else:            x -= speed        self.rect.center = (x, y)# platform mechanismclass Platform(pygame.sprite.Sprite):    # initial settings    # asking Program if landable    def __init__(self, Landable, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        width, height = surface.get_size()        # if there is no specific image then use random        # if not landable then use lava block image.        if image == None:            plat_dir = listdir('platforms/' + dir)            bad_dir = listdir('badObjects/' + dir)            plat_max_len = len(plat_dir) - 1            bad_max_len = len(bad_dir) - 1            for item in plat_dir:                if isdir(item):                    plat_max_len -= 1            for item in bad_dir:                if isdir(item):                    bad_max_len -= 1            if Landable:                self.image = pygame.image.load(                    'platforms/' + dir + '/platform_' + str(random.randint(0, plat_max_len)) + '.png')            else:                self.image = pygame.image.load(                    'badObjects/' + dir + '/badplat' + str(random.randint(0, bad_max_len - 1)) + '.png')        else:            self.image = pygame.image.load(image)        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        # General settings        self.rect = self.image.get_rect()        self.rect.center = (random.randrange(width * 1.25, width * 2), random.randrange(height * 8 // 12, height * 5 // 6))    # self.pos = vec((self.rect.center))# Seagulls classclass Seagull(pygame.sprite.Sprite):    # initial settings    def __init__(self, dir="ground", surface=screen, image=None):        super().__init__()        width, height = surface.get_size()        if image == None:            self.image = pygame.image.load('badObjects/' + dir + '/air/seagull.png')        else:            self.image = pygame.image.load(image)        self.rect = self.image.get_rect()        self.rect.center = (random.randint(width, width * 2), random.randint(0, height * 5 // 24))        self.x, self.y = self.rect.center    # Update mechanism    def update(self):        self.x -= PlayerSpeed * 1.15        self.rect.center = (self.x, self.y)        if pygame.sprite.spritecollide(self, players, False):            self.image = pygame.image.load("misc/explosion.png")            self.rect = self.image.get_rect()            self.rect.center = (self.x, self.y)        # if seagull is out of screen then kill it        if self.x < 0:            all_sprites.remove(self)            danger.remove(self)            seagulls.remove(self)            self.kill()class PlayerObject():    def __init__(self, name, sizeFactor):        self.name = name        if not multiBool:            self.sideLength = 40        else:            self.sideLength = 35        self.sizeFactor = sizeFactor        self.image = pygame.image.load("players/"+name+".png")class Projectile(pygame.sprite.Sprite):    def __init__(self, pos, image="misc/fireball.png"):        super().__init__()        self.image = pygame.image.load(image)        self.fire = pygame.image.load("misc/fire.png")        self.rect = self.image.get_rect()        self.rect.center = pos        self.pos = pos        self.damage = 0.05    def update(self):        if pygame.sprite.spritecollideany(self, players):            self.image = self.fire            playerHit = pygame.sprite.spritecollide(self, players, False)[-1]            playerHit.health -= self.damage            self.kill()        else:            self.rect.centerx += 20            if self.rect.centerx > self.pos[0] + 240:                self.image = self.fire                self.rect.center = self.rect.midtop            if self.rect.centerx > self.pos[0] + 300:                self.kill()# Player classclass Player(pygame.sprite.Sprite):    # initial settings    def __init__(self, playerObject, AIMode=False, surf=screen, player1Bool=True):        super().__init__()        self.sideLength = playerObject.sideLength        # Temporary variable only used inside __init__ method        sizeFactor = playerObject.sizeFactor        self.image = playerObject.image        self.image = pygame.transform.scale(self.image, (self.sideLength // sizeFactor, self.sideLength // sizeFactor))        self.blownup = pygame.image.load("misc/explosion.png")        self.blownup = pygame.transform.scale(self.blownup, (100, 100))        self.rect = self.image.get_rect()        self.rect.center = (width // 2, 0)        self.health = 3        self.acc = 0        self.relpos = vec(self.rect.center)        self.name = playerObject.name        self.jumpstate = True        self.dead = False        self.AIMode = AIMode        self.jumpGame = False        self.moveBools = [False, False]        if self.AIMode:            self.jumpstate = False        self.vel = 0        self.prevVel = 0        self.rectify_pos = False        # Can use powerups True|False        self.powerUpBool = True        self.powerUps = []        self.player1Bool = player1Bool        self.fric = -0.30        self.screen = surf        self.raceBool = False        self.canMove = True        self.raceSpeed = 4        self.enemy = None        self.fuel = 1        self.fire_gen = 0    def fire(self, pos):        self.fire_gen += 1        if self.fire_gen % 2 == 0 and self.fire_gen != 0:            if self.fuel > 0:                proj = Projectile(pos)                proj.add(danger)                proj.add(projGroup)                self.fuel -= 0.00                self.fire_gen = 0    def race(self, keys):        if self.rect.centerx <= width * 4//6:            if self.player1Bool:                if keys[K_RIGHT]:                    self.rect.centerx += self.raceSpeed                if keys[K_LEFT]:                    self.rect.centerx -= self.raceSpeed            else:                if keys[K_d]:                    self.vel += self.raceSpeed                if keys[K_a]:                    self.vel -= self.raceSpeed    def move(self, keys):        if self.player1Bool:            if keys[K_RIGHT]:                self.vel += PSD//4            if keys[K_LEFT]:                self.vel -= PSD//4        else:            if keys[K_d]:                self.vel += PSD//4            if keys[K_a]:                self.vel -= PSD//4        if self.vel >= PSD * 3:            self.vel = PSD * 3        elif self.vel <= -PSD * 3:            self.vel = -PSD * 3        if self.rect.midright[0] > width * 5//6:            # self.rect.midright = (width * 5//6, self.rect.midright[1])            self.rect.midright = (self.rect.midright[0] + self.vel, self.rect.midright[1])            # self.vel -= 1        elif self.rect.midleft[0] < width//6:            # self.rect.midleft = (width//6, self.rect.midleft[1])            self.rect.midleft = (self.rect.midleft[0] + self.vel, self.rect.midleft[1])            # self.vel += 1        else:            if self.vel != 0:                self.prevVel = self.vel            if self.vel < 0:                self.rect.centerx += self.vel - self.fric            if self.vel > 0:                self.rect.centerx += self.vel + self.fric            self.moveBools = [False, False]        if pygame.sprite.spritecollideany(self, platforms):            if self.vel < 0:                self.vel -= self.fric            if self.vel > 0:                self.vel += self.fric    # Jump mechanism    def jump(self, keys, jumpForce=20):        x, y = self.rect.center        # Event handling        if not self.AIMode:            if self.player1Bool:                if keys[K_SPACE]:                    # jumping                    y -= jumpForce            else:                if keys[K_w]:                    y -= jumpForce            if p1Pad != None:                if p1Pad.get_button(0):                    y -= jumpForce        else:            y -= jumpForce        # Updating position        self.rect.center = (x, y)    def AI(self):        if width * 4 // 6 >= self.rect.centerx > width // 6:            if self.raceBool and self.canMove:                if self.enemy.rect.centerx > self.rect.centerx - 100 or self.enemy.rect.centerx < self.rect.centerx + 100:                    self.rect.centerx += self.raceSpeed                else:                    self.rect.centerx -= self.raceSpeed        else:            self.canMove = False        if self.rect.centerx <= width * 3 // 6:            self.canMove = True        if pygame.sprite.spritecollideany(self, projGroup):            self.jumpstate = True            if self.rect.centerx > width//3:                self.rect.centerx -= 4        elif pygame.sprite.spritecollideany(self, platforms):            self.jumpstate = False            if self.raceBool:                if self.rect.centerx < self.enemy.rect.centerx - 50:                    self.fire((self.rect.midright[0] + 20, self.rect.midright[1] - 40))                    self.fire((self.rect.midright[0] + 60, self.rect.midright[1]))                    self.fire((self.rect.midright[0] + 20, self.rect.midright[1] + 40))            collided_platform = pygame.sprite.spritecollide(self, platforms, False)[-1]            next_platform = None            # Calculate index number for collided platform            index = 0            for plat in platforms.sprites():                if plat == collided_platform:                    next_platform = platforms.sprites()[index + 1]                    break                index += 1            distance = (next_platform.rect.midleft[0] - collided_platform.rect.midright[0])            if distance <= 80 and self.rect.centery <= collided_platform.rect.midtop[0]:                self.jumpstate = False            elif distance <= 200 and self.rect.centery <= collided_platform.rect.midtop[0]:                if self.rect.y <= 10:                    self.jumpstate = False            elif self.rect.centerx >= collided_platform.rect.midright[0] or self.rect.centery >= collided_platform.rect.midtop[1]:                self.jumpstate = True    # Gravity mechanics    def gravity(self, gravityDecimal=0.5):        x, y = self.rect.center        # checking for collision        # If not then continue falling and updating position        if not pygame.sprite.spritecollide(self, platforms, False):            y += self.acc            self.acc += gravityDecimal            self.rect.center = (x, y)        # else stop and update position        else:            self.acc = 0            self.rect.center = (x, y)    # The Update mechanism    def update(self, jumpForce=20, gravity=0.5, otherGroup=danger):        x, y = self.rect.midtop        keys = pygame.key.get_pressed()        # Updating Position        self.rect.midtop = (x, y)        if pygame.sprite.spritecollideany(self, platforms):            currPlat = pygame.sprite.spritecollide(self, platforms, False)[-1]            self.jumpstate = True            if self.rect.midtop[1] < currPlat.rect.midtop[1] and self.rect.centery > currPlat.rect.midtop[1]:                self.rect.centery = currPlat.rect.midtop[1]            elif self.rect.midtop[1] > currPlat.rect.midtop[1]:                if self.rect.centerx > currPlat.rect.midleft[0] and self.rect.centerx < currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midleft[0]                elif self.rect.centerx < currPlat.rect.midright[0] and self.rect.centerx > currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midright[0]        # Updating relative position        self.relpos.x += PlayerSpeed        if self.jumpGame:            self.move(keys)        if self.raceBool:            self.race(keys)        if self.AIMode:            self.AI()        else:            if keys[K_x]:                sleep(0.005)                self.fire((self.rect.midright[0] + 20, self.rect.midright[1]))        # If not in air allow jump mechanism        if self.jumpstate:            self.jump(keys, jumpForce)        # Running virtual gravity method        self.gravity(gravity)        if pygame.sprite.spritecollide(self, otherGroup, False):            if self.health <= 0:                self.image = self.blownup                self.rect = self.image.get_rect()                self.rect.midtop = (x, y)class PlatDecorations(pygame.sprite.Sprite):    def __init__(self, platform, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        self.ok = True        if image != None:            self.image = pygame.image.load(image)        else:            decor_max_len = len(listdir('decorations/' + dir)) - 1            self.image = pygame.image.load(                'decorations/' + dir + '/decor_' + str(random.randint(0, decor_max_len)) + '.png')        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        if platform == None:            print("Cannot summon decoration, specified platform is None")            self.ok = False        self.rect = self.image.get_rect()        self.platform = platform        self.surface = surface        self.image.set_alpha(200)    def update(self):        self.rect.midbottom = self.platform.rect.midtop        x, y = self.rect.midbottom        self.rect.midbottom = (x, y + self.image.get_height() * 1 // 6)        if self.rect.centerx <= 0:            self.kill()class PlayerTag(pygame.sprite.Sprite):    def __init__(self, player, number):        super().__init__()        font = pygame.font.Font("fonts/pixelart.ttf", 40)        self.image = font.render(number, BG2, (55, 255, 55))        self.num = number        self.player = player        self.rect = self.image.get_rect()        self.rect.midbottom = self.player.rect.midtop    def update(self):        self.rect.midbottom = self.player.rect.midtop        if not self.player:            self.kill()# Levels Classclass Level():    def __init__(self, bg, spriteDirs, song, startblock, factor=1, playerStartSpeed=PSD, moveBool=False, gravity=0.5, jumpForce=20, name="Unknown Level", diff="easy", zoomMode=False):        self.bg = bg        self.factor = factor        self.diff = diff        self.name = name        self.zoomMode = zoomMode        if self.bg != None:            self.noBG = False            self.bg = "backgrounds/" + bg        else:            self.noBG = True            self.bg = "backgrounds/Unknown.png"        self.bgSong = song        self.platDir, self.cloud = spriteDirs        self.jumpForce = jumpForce        self.gravity = gravity        self.psd = playerStartSpeed        self.moveBool = moveBool        self.startblock = startblock    def loadBG(self, surf=screen):        self.image = pygame.image.load(self.bg)        if self.zoomMode:            self.image = pygame.transform.scale(self.image, (surf.get_width()*2, surf.get_height()*2)).convert()        else:            self.image = pygame.transform.scale(self.image, surf.get_size())        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, surf.get_height())class CoopLevel():    def __init__(self, backgrounds, spriteDir, startblock, song, factor=1, gravity=0.5, jumpForce=20, PlayerStartSpeed=PSD, moveBool=False, name="Unknown Level", diff="easy"):        self.bg1 = backgrounds        self.bgSong = song        self.name = name        self.bg1 = "backgrounds/dual-BGs/" + self.bg1        self.startblock = startblock        self.diff = diff        self.factor = factor        self.platDir = spriteDir        self.psd = PlayerStartSpeed        self.moveBool = moveBool        self.gravity = gravity        self.jumpForce = jumpForce    def loadBG(self, size1):        self.image1 = pygame.image.load(self.bg1)        self.image1 = pygame.transform.scale(self.image1, size1)        self.rect1 = self.image1.get_rect()        self.rect2 = self.image1.get_rect()        self.rect1.topleft = (0, 0)        self.rect2.topleft = (0, -self.image1.get_height()//2)class Line(pygame.sprite.Sprite):    def __init__(self, thickness, alpha, color, pos, length=screen.get_width()):        super().__init__()        self.alpha = alpha        self.image = pygame.Surface((length, thickness))        self.image.fill(color)        self.image.set_alpha(self.alpha)        self.rect = self.image.get_rect()        self.rect.topleft = posclass PowerUp(pygame.sprite.Sprite):    def __init__(self, name, rootPlayer=None, pos=(0, 0)):        self.name = name        self.rootPlayer = rootPlayer        self.image = pygame.image.load("misc/" + name + ".png")        self.rect = self.image.get_rect()        self.act = False        self.rect.center = pos        if name == "fireball" or name == "air_attack" or name == "rock":            self.action = self.fire()    def heal(self):        if self.rootPlayer.health < 1:            self.rootPlayer.health += 0.12        else:            self.kill()    def fire(self):        if self.rootPlayer.player1Bool:            self.rect.centerx += 3        else:            self.rect.centerx -= 3    def update(self):        if self.rootPlayer != None:            if self.act:                self.action()        if pygame.sprite.spritecollideany(self, players):            self.kill()class Monitor(pygame.sprite.Sprite):    def __init__(self, powerUp="fireball"):        super().__init__()        self.image = pygame.image.load("monitors/monitor_" + powerUp.name + ".png")        self.image = pygame.transform.scale(self.image, (self.image.get_width() * 2, self.image.get_height() * 2))        self.broken = pygame.image.load("monitor/monitor_broken.png")        self.broken = pygame.transform.scale(self.broken, (self.image.get_width() * 2, self.image.get_height() * 2))        self.sound = pygame.mixer.Sound("sounds/pop.wav")        self.powerUp = powerUp        self.rect = self.image.get_rect()    def update(self, surfGroup=platforms, gravForce=0.5):        if pygame.sprite.spritecollideany(self, players):            player = pygame.sprite.spritecollide(self, players, False)[-1]            player.fuel = 1            self.sound.play()            self.image = self.broken            self.image.set_alpha(150)class Text(pygame.sprite.Sprite):    def __init__(self, str, BG_FG_Color, script, pos):        super().__init__()        self.image = script.render(str, BG_FG_Color[0], BG_FG_Color[1])        self.rect = self.image.get_rect()        self.rect.center = posclass Boss(pygame.sprite.Sprite):    def __init__(self, name, homePlat):        super().__init__()        self.size = (839//2, 640//2)        self.walk_slides = returnFrames("bosses/" + name + "/" + name + "_walk.gif", self.size, True)        self.fire_slides = returnFrames("bosses/" + name + "/" + name + "_fire.gif", self.size, True)        self.invert_walk_slides = returnFrames("bosses/" + name + "/" + name + "_inverted_walk.gif", self.size, True)        self.invert_fire_slides = returnFrames("bosses/" + name + "/" + name + "_inverted_fire.gif", self.size, True)        self.idle = self.fire_slides[0]        self.image = self.idle        self.rect = self.image.get_rect()        self.base_plat = homePlat        self.rect.midbottom = (self.base_plat.rect.midtop[0], self.base_plat.rect.midtop[1] + 20)        self.functions = ["walk", "fire", "stay", "invertWalk", "invertFire", "invertStay", "radar"]        self.currentFunc = self.functions[0]        self.commands = ["patrol", "locateEnemy"]        self.currentCommand = self.commands[0]        self.index = 0    def update(self):        # Patrol action        if self.currentCommand == "patrol":            if self.currentFunc == "walk":                self.image = self.walk_slides[int(self.index)]                if self.index < len(self.walk_slides) - 1:                    self.index += 0.1                else:                    self.index = 0                if self.rect.midleft[0] > self.base_plat.rect.midleft[0]:                    self.rect.centerx -= 0.3                else:                    self.index = 0                    self.currentFunc = "invertWalk"                    self.update()            if self.currentFunc == "invertWalk":                self.image = self.invert_walk_slides[int(self.index)]                if self.index < len(self.invert_walk_slides) - 1:                    self.index += 0.1                else:                    self.index = 0                if self.rect.centerx < self.base_plat.rect.topright[0]:                    self.rect.centerx += 0.3                else:                    self.index = 0                    self.currentFunc = "walk"                    self.update()class HealthBar(pygame.sprite.Sprite):    def __init__(self, player, surf):        super().__init__()        self.images = [            pygame.image.load("healthbars/bar0.png"),            pygame.image.load("healthbars/bar1.png"),             pygame.image.load("healthbars/bar2.png"),             pygame.image.load("healthbars/bar3.png")        ]        self.image = self.images[-1]        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, surf.get_height())        self.player = player    def update(self):        self.image = self.images[int(self.player.health)]levels = [    Level("earth.png", ("space", None), "neon-run.ogg", "platform_5.png", 10, 11, False, 0.15, 10, "Orbital Strike"),    Level("neon-city.png", ("neon", None), "extsong.ogg", "platform_4.png", 10, 15, False, 1, 30, "Neon City", zoomMode=True),    Level("neon-landscape.png", ("neon", None), "neon-scape.ogg", "platform_4.png", 7, 5, False, 1, 30, "Neon outscape"),    Level("volcano-dash.png", ("ground", "cloud.png"), "lava-run.ogg", "platform_3.png", 11, 5, False, 1, 30, "Huanuna Island"),    Level("planet-run.png", ("ground", "cloud.png"), "planet-run2.ogg", "platform_3.png", 11, 18, False, 1, 30, "Exo Dash", zoomMode=True),    Level("candyland.png", ("candy", None), "song-3.ogg", "platform_1.png", 11, 5, False, 1, 30, "Candyland", zoomMode=True),    Level("overworld.png", ("ground", None), "overworld.ogg", "platform_3.png", 11, 5, False, 1, 30, "Overworld"),    Level("pyramids.png", ("sand", "cloud.png"), "pyramid.ogg", "platform_0.png", 11, 5, False, 1, 30, "The Pyramids"),    Level("jungle.png", ("jungle", None), "jungle.ogg", "platform_5.png", 11, 5, False, 1, 30, "The Amazon Jungle"),    Level("palmtree.png", ("jungle", None), "palmtree-dance.ogg", "platform_5.png", 11, 7, False, 1, 30, "Palmtree Dance"),]multiplayerLevels = [    CoopLevel("earthdual1.png", "space", "platform_5.png", "dual-BGMs/dual.ogg", 10, 0.3, 15,              name="Satellite in Orbit"),    CoopLevel("neon-dual1.png", "neon", "platform_4.png", "dual-BGMs/neon-dual.ogg", 10, 1, 30,              name="Neon City"),    CoopLevel("mars-dual1.png", "space", "platform_5.png", "dual-BGMs/mars-dual.ogg", 10, 0.3, 15,              name="The red planet"),    CoopLevel("super-dual1.png", "neon", "platform_4.png", "dual-BGMs/super-dual.ogg", 10, 1, 30,              name="Microchip"),    CoopLevel("nebula-dual1.png", "neon", "platform_4.png", "dual-BGMs/nebula-dual.ogg", 10, 1,              30, name="The Nebula\'s hidden layer"),    CoopLevel("exo-dual1.png", "ground", "platform_3.png", "dual-BGMs/planet-dual.ogg", 10, 1, 30,              name="Exo-Planet run"),    CoopLevel("candy-dual1.png", "candy", "platform_1.png", "dual-BGMs/candy-dual.ogg", 10, 1, 30,              name="Sugar Rush", diff="Hard if you are on a diet"),    CoopLevel("pyramids1.png", "sand", "platform_0.png", "dual-BGMs/pyramid-run.ogg", 10, 1, 30,              name="Pyramid Chase"),    CoopLevel("AI-Demo1.png", "space", "platform_5.png", "dual-BGMs/ai-dual.ogg", 10, 0.3, 15,              name="AI Demo"),    CoopLevel("saturn.png", "space", "platform_5.png", "dual-BGMs/saturn.ogg", 10, 0.3, 15, name="Saturn\'s rings"),    CoopLevel("deep_space.png", "space", "platform_5.png", "dual-BGMs/deep_space.ogg", 10, 0.3, 15, name="Deep Space", diff="Fun!"),    CoopLevel("palmtree.png", "jungle", "platform_3.png", "dual-BGMs/palmtree-run.ogg", 10, 1, 30, name="Palmtree Race")]def scanlines(thickness=1):    if scanlineBool:        for i in range(screen.get_height()):            if i % (thickness * 2) == 0:                scanlineGroup.add(Line(thickness, 100, (0, 0, 0), (0, i)))scanlines()def returnFrames(src, size, transparency=False):    slides = cv2.VideoCapture(src)    imageList = []    while True:        ret, frame = slides.read()        if not ret:            break        shape = frame.shape[1::-1]        img = pygame.image.frombuffer(frame.tobytes(), shape, "BGR").convert_alpha()        img = pygame.transform.scale(img, size)        if transparency:            img.set_colorkey((255, 255, 255))        imageList.append(img)    slides.release()    return imageListloading = pygame.image.load("backgrounds/loading.png")loading = pygame.transform.scale(loading, res)screen.blit(loading, (0, 0))pygame.display.update()lvlSelect_Anim = returnFrames("backgrounds/levelSelect.gif", res)startup_1 = returnFrames("backgrounds/startup-1.gif", res)startup_2 = returnFrames("backgrounds/startup-2.gif", res)help_bg = returnFrames("backgrounds/help.gif", res)GMSelect_Anim = returnFrames("backgrounds/gameModeSelect.gif", res)classicLevel = Level(None, ("classic", "cloud.png"), None, "platform_0.png", 11, 5, False, 1, 25, "classic")playersList = [    PlayerObject("wasp", 1),    PlayerObject("stingray", 1),    PlayerObject("red", 1),    PlayerObject("classic", 1)]sequences = {    "arcadeSelect": [0, 3, 1, 2],    "bonusUnlock": [1, 0, 1, 2],    "indevUnlock": [2, 0, 2, 1],    "debugModeUnlock": [4, 4, 2, 0],    "AllAbove": [7, 7, 0, 3]}songsList = [    "songs/Extras/menu.ogg",    "songs/Extras/multiplayer.ogg",    "songs/startups/startup.ogg",    "songs/classics/classic-0.ogg",    "songs/help.ogg",    "songs/song-3.ogg",    "songs/planet-run2.ogg"]enemy = PlayerObject("enemy", 1)enemy2 = PlayerObject("enemy_2", 1)enemyFreq = [1, 10]dummy1 = [playersList[0], False]dummy2 = [playersList[2], True]def multiplayerDual(p1, p2, data=[]):    healthbarGroup = pygame.sprite.Group()    textGroup = pygame.sprite.Group()    monitorGroup = pygame.sprite.Group()    for item in danger:        item.remove(projGroup)        item.remove(danger)        item.kill()    for player in players.sprites():        player.remove(players)        player.kill()    for item in platforms.sprites():        item.remove(platforms)        item.remove(all_sprites)        item.kill()    p1Object, p1AIBool = p1    p2Object, p2AIBool = p2    player1 = Player(p1Object, p1AIBool)    player2 = Player(p2Object, p2AIBool, player1Bool=False)    player1.rect.centerx -= 20    player1.enemy = player2    player2.enemy = player1    font = pygame.font.Font("fonts/ka1.ttf", 35)    p1Healthbar = HealthBar(player1, screen)    p2Healthbar = HealthBar(player2, screen)    healthbarGroup.add(p1Healthbar)    healthbarGroup.add(p2Healthbar)    p1Healthbar.rect.topleft = (0, 0)    player1.raceBool = player2.raceBool = True    players.add(player1)    players.add(player2)    plat1 = Platform(True, image="platforms/space/platform_3.png")    plat1.image = pygame.transform.scale(plat1.image, (screen.get_width(), screen.get_height()* 2//3))    plat1.rect = plat1.image.get_rect()    plat1.rect.midleft = (0, screen.get_height())    main_y_coord = plat1.rect.midtop[1]    plat1.kill()    tmp_plat = Platform(True, image="platforms/space/platform_5.png")    tmp_plat.rect.center = (width, main_y_coord)    tmp_plat.add(platforms)    player2.rect.bottomleft = tmp_plat.rect.topleft    p1Name = Text(player1.name, (None, (255, 255, 255)), font, (0, 0))    p1Name.rect.midtop = p1Healthbar.rect.midbottom    p2Name = Text(player2.name, (None, (255, 255, 255)), font, (0, 0))    p2Name.rect.midbottom = p2Healthbar.rect.midtop    textGroup.add(p1Name)    textGroup.add(p2Name)    font = pygame.font.Font("fonts/ka1.ttf", 50)    speed = 5    ended = False    blue = (89, 153, 255)    p1Wins = Text("Player 1 Wins", (None, blue), font, (screen.get_width() // 2, screen.get_height() // 2))    p2Wins = Text("Player 2 Wins", (None, blue), font, (screen.get_width() // 2, screen.get_height() // 2))    finalWin = None    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_ESCAPE:                    enterOpp()                    startScreen()                    exit()        screen.fill((0, 0, 0))        for player in players.sprites():            player.rect.centerx -= 1            if player.rect.centery > height or player.rect.midright[0] < 0:                player.health = 0        if not ended:            if speed <= 100:                speed += 0.3        else:            if speed >= 20:                speed -= 0.2            else:                speed = 20        for plat in platforms:            plat.rect.centerx -= int(speed)            if plat.rect.midright[0] < -15:                plat.remove(platforms)                plat.kill()        for i in range(10):            new_plat = Platform(True, image="platforms/space/platform_5.png")            new_plat.rect.centery = main_y_coord            if pygame.sprite.spritecollideany(new_plat, platforms):                new_plat.kill()            else:                new_plat.add(platforms)            if i % 10 == 0 and i != 0:                tmp_monitor = Monitor()                tmp_monitor.rect.midbottom = new_plat.rect.midtop                tmp_monitor.add(monitorGroup)                tmp_monitor.add(platforms)        if player2.health <= 0:            player2.AIMode = False            player2.image = player2.blownup            player2.rect.centerx -= int(speed)            player1.AIMode = True            ended = True            finalWin = p1Wins            player1.health = 1            player1.rect.centerx = screen.get_width() // 2        if player1.health <= 0:            player1.AIMode = False            player1.image = player1.blownup            player1.rect.centerx -= int(speed)            player2.AIMode = True            ended = True            finalWin = p2Wins            player2.health = 1            player2.rect.centerx = screen.get_width()//2        if ended:            textGroup.add(finalWin)            keys = pygame.key.get_pressed()            if keys[K_r]:                multiplayerDual(p1, p2, data)                exit()            if keys[K_RETURN]:                enterOpp()                bonusMain(levels[random.randint(0, len(levels)-1)], data[1] + 4, data[2], p1)                exit()        players.update()        projGroup.update()        healthbarGroup.update()        monitorGroup.update()        players.draw(screen)        platforms.draw(screen)        projGroup.draw(screen)        healthbarGroup.draw(screen)        textGroup.draw(screen)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)#def soundTest():def bonusHelpScreen():    for item in danger:        item.remove(danger)        item.kill()    pygame.mixer.music.load("songs/bonus_help.ogg")    pygame.mixer.music.play(-1)    clouds = pygame.sprite.Group()    contentGroup = pygame.sprite.Group()    fontColor = (240, 240, 240)    header = pygame.font.Font("fonts/segaArt.ttf", 70)    sub = pygame.font.Font("fonts/ka1.ttf", 20)    title = Text("Manual", (None, fontColor), header, (0, 0))    title.rect.topleft = (60, 30)    f = open("files/bonus_help.txt")    lines = f.readlines()    f.close()    firstLine = Text(lines[0], (None, fontColor), sub, (0, 0))    firstLine.rect.topleft = title.rect.bottomleft    contentGroup.add(firstLine)    speed = 2    indexCount = 0    for line in lines:        if line == lines[0]:            continue        else:            tmp = Text(line, (None, fontColor), sub, (0, 0))            tmp.rect.topleft = contentGroup.sprites()[-1].rect.bottomleft            contentGroup.add(tmp)    for i in range(40):        new_cloud = Clouds((random.randint(0, width), random.randint(0, height)))        if i > 16:            new_cloud.image.set_alpha(255)            new_cloud.speed = 2        else:            new_cloud.image.set_alpha(150)            new_cloud.speed = 1        if pygame.sprite.spritecollideany(new_cloud, clouds):            new_cloud.kill()        else:            clouds.add(new_cloud)    y = firstLine.rect.topleft[1]    player = None    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            elif event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_ESCAPE]:                    for plat in platforms:                        plat.remove(platforms)                        plat.kill()                    bonusStartScreen()                    exit()                if keys[K_UP]:                    if contentGroup.sprites()[-1].rect.bottomleft[1] > height* 5//6:                        y -= 20                if keys[K_DOWN]:                    if firstLine.rect.topleft[1] < title.rect.bottomleft[1]:                        y += 20        if indexCount % 200 == 0 and indexCount != 0:            if player == None:                player = Player(playersList[random.randint(0, len(playersList) - 1)], True)                player.rect.center = (0, 0)        for plat in platforms:            plat.rect.centerx -= speed * 2            if plat.rect.midright[0] < 0:                plat.remove(platforms)                plat.kill()        for i in range(10):            new_plat = Platform(True, dir="classic")            new_plat.rect.centerx -= width//2            if pygame.sprite.spritecollideany(new_plat, platforms):                new_plat.kill()            else:                platforms.add(new_plat)        for i in range(len(contentGroup.sprites())):            currLine = contentGroup.sprites()[i]            if currLine == firstLine:                continue            prevLine = contentGroup.sprites()[i - 1]            currLine.rect.topleft = prevLine.rect.bottomleft        clouds.update()        screen.fill(BG)        clouds.draw(screen)        if player != None:            if player.rect.midleft[0] > width:                player.kill()                player = None                continue            player.update(20, 1)            player.rect.centerx += speed            screen.blit(player.image, player.rect)        platforms.draw(screen)        screen.blit(title.image, title.rect)        contentGroup.draw(screen)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)        indexCount += 1def bonusStartScreen():    pygame.mixer.music.load("songs/startups/startup-3.ogg")    pygame.mixer.music.play(-1)    cloudsGroup1 = pygame.sprite.Group()    cloudsGroup2 = pygame.sprite.Group()    textGroup = pygame.sprite.Group()    header = pygame.font.Font("fonts/pixelart.ttf", 50)    header2 = pygame.font.Font("fonts/pixelart.ttf", 45)    sub = pygame.font.Font("fonts/pixelart.ttf", 25)    fontColor = (245, 245, 245)    title = Text("Sky Dash Classic", (None, fontColor), header, (screen.get_width()//2, screen.get_height()//3))    startOp = Text("Start", (None, fontColor), sub, (0, 0))    helpOp = Text("Manual", (None, fontColor), sub, (0, 0))    quitOp = Text("Back To Menu", (None, fontColor), sub, (0, 0))    cursor1 = Text(">", (None, (150, 255, 150)), sub, (0, 0))    cursor2 = Text("<", (None, (150, 255, 150)), sub, (0, 0))    startOp.rect.midbottom = (screen.get_width()//2, screen.get_height()//2)    helpOp.rect.midtop = startOp.rect.midbottom    quitOp.rect.midtop = helpOp.rect.midbottom    options = [startOp, helpOp, quitOp]    textGroup.add(title)    textGroup.add(startOp)    textGroup.add(quitOp)    textGroup.add(helpOp)    textGroup.add(cursor1)    textGroup.add(cursor2)    index = 0    cloudsList = []    for i in range(5):        new_cloud = Clouds((random.randint(0, screen.get_width()), random.randint(0, screen.get_height())))        if pygame.sprite.spritecollideany(new_cloud, cloudsGroup1):            new_cloud.kill()            i -= 1        else:            new_cloud.image.set_alpha(200)            cloudsGroup1.add(new_cloud)            cloudsList.append(new_cloud)    for i in range(5):        new_cloud = Clouds((random.randint(0, screen.get_width()), random.randint(0, screen.get_height())))        if pygame.sprite.spritecollideany(new_cloud, cloudsGroup2):            new_cloud.kill()            i -= 1        else:            cloudsGroup2.add(new_cloud)            cloudsList.append(new_cloud)    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_ESCAPE]:                    startScreen()                    break                if keys[K_DOWN]:                    index += 1                if keys[K_UP]:                    index -= 1                if keys[K_RETURN]:                    if options[index] == quitOp:                        enterOpp()                        startScreen()                        break                    if options[index] == startOp:                        bonusMain(classicLevel, 0, True, player=[playersList[-1], False])                        break                    if options[index] == helpOp:                        bonusHelpScreen()                        break        if index < 0:            index = len(options) - 1        if index > len(options) - 1:            index = 0        currOp = options[index]        cursor1.rect.midright = currOp.rect.midleft        cursor2.rect.midleft = currOp.rect.midright        screen.fill(BG)        for cloud in cloudsList:            x = cloud.rect.center[0]            if x < 0 - cloud.image.get_width():                x = width + cloud.image.get_width()            else:                if cloudsGroup1.has(cloud):                    x -= 3                if cloudsGroup2.has(cloud):                    x -= 2            cloud.rect.center = (x, cloud.rect.center[1])        cloudsGroup1.draw(screen)        textGroup.draw(screen)        cloudsGroup2.draw(screen)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)def levelSelect(list, func):    font = pygame.font.Font("fonts/pixelart.ttf", 20)    headerFont = pygame.font.Font("fonts/segaArt.ttf", 70)    fontColor = (64, 125, 120)    headerColor = (69, 129, 181)    levelMenu = pygame.Surface((screen.get_width() * 2 // 3, screen.get_height()))    menuRect = levelMenu.get_rect()    menuRect.topleft = (screen.get_width() // 3, 0)    cursor = font.render(">", BG2, (55, 255, 55))    cursorRect = cursor.get_rect()    cursorRect.topleft = (0, 0)    prevWin = pygame.Surface((screen.get_width() // 3 - 20, screen.get_height() // 4))    prevRect = prevWin.get_rect()    prevRect.topleft = (10, screen.get_height() // 4)    win1 = pygame.Surface((screen.get_width()//3, screen.get_height()))    win2 = pygame.Surface((win1.get_width(), win1.get_height()))    win1.fill((0, 0, 0))    win2.fill((0, 0, 0))    win1Rect = win1.get_rect()    win2Rect = win2.get_rect()    win1Rect.topleft = (0, 0)    win2Rect.topright = (screen.get_width(), 0)    win1Prev = pygame.Surface((160, 160))    win2Prev = pygame.Surface((win1Prev.get_width(), win1Prev.get_height()))    prev1Rect = win1Prev.get_rect()    prev2Rect = win2Prev.get_rect()    prev1Rect.center = win1Rect.center    prev2Rect.center = win2Rect.center    lineList = []    bgList = []    diffList = []    playerSelect = Text("Select Character", (None, headerColor), headerFont, (screen.get_width()//2, 50))    player1 = Text("Player 1", (None, fontColor), font, (win1.get_width()//2, win1.get_height()//3))    player2 = Text("Player 2", (None, fontColor), font, (win2Rect.topleft[0] + win2.get_width()//2, win2.get_height()//3))    p1 = font.render("Player 1:", BG2, fontColor)    p2 = font.render("Player 2:", BG2, fontColor)    header = font.render("AI On/Off", BG2, (131, 214, 153))    p1On = font.render("On", BG2, (55, 255, 55))    p1Off = font.render("Off", BG2, (55, 255, 55))    p2On = font.render("On", BG2, (55, 255, 55))    p2Off = font.render("Off", BG2, (55, 255, 55))    p1_state = [True, False]    p2_state = [True, False]    p1Rect = p1.get_rect()    p2Rect = p2.get_rect()    headerRect = header.get_rect()    p1OnRect = p1On.get_rect()    p1OffRect = p1Off.get_rect()    p2OnRect = p2On.get_rect()    p2OffRect = p2Off.get_rect()    p1Itr = 1    p2Itr = 1    p1Object = None    p2Object = None    i = 0    for level in list:        tmp = font.render(level.name, BG2, fontColor)        tmpRect = tmp.get_rect()        tmpRect.topleft = (20, i * tmp.get_height() + 5)        diff = font.render(level.diff, BG2, (152, 32, 32))        diffRect = diff.get_rect()        lineList.append((tmp, tmpRect, level))        diffList.append((diff, diffRect))        if not multiBool:            image = pygame.image.load(level.bg)            image = pygame.transform.scale(image, prevWin.get_size())            rect = image.get_rect()            rect.topleft = (0, 0)            bgList.append((image, rect))        else:            image = pygame.image.load(level.bg1)            image = pygame.transform.scale(image, prevWin.get_size())            rect = image.get_rect()            rect.topleft = (0, 0)            bgList.append((image, rect))        i += 1    # clear rubish from screen    screen.fill((0, 0, 0))    itr = 0    row = 0    itrRow = [p1Itr, p2Itr]    run = True    mainLevel = None    index = 0    while run:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_UP]:                    if itr <= 0:                        itr = len(lineList) - 1                    else:                        itr -= 1                    break                if keys[K_DOWN]:                    if itr >= len(lineList) - 1:                        itr = 0                    else:                        itr += 1                    break                if keys[K_RETURN]:                    if multiBool:                        mainLevel = level                        run = False                        break                    else:                        # Needs to be fixed                         func(level)                    startScreen()                    break                if keys[K_ESCAPE]:                    startScreen()                    break        tmp, lnRect, level = lineList[itr]        bgImage, bgRect = bgList[itr]        diff, diffRect = diffList[itr]        diffRect.topleft = prevRect.bottomleft        cursorRect.midright = lnRect.midleft        if index >= len(lvlSelect_Anim) - 1:           index = 0           continue        else:           index += 1        bg = lvlSelect_Anim[index]        screen.blit(bg, (0, 0))        levelMenu.fill((0, 0, 0))        levelMenu.set_alpha(150)        prevWin.blit(bgImage, bgRect)        screen.blit(diff, diffRect)        for line in lineList:            lineIMG, lineRect, tmp = line            levelMenu.blit(lineIMG, lineRect)        levelMenu.blit(cursor, cursorRect)        screen.blit(levelMenu, menuRect)        screen.blit(prevWin, prevRect)        scanlineGroup.draw(prevWin)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)    run = True    selectPlayers = True    if multiBool:        win1.set_alpha(125)        win2.set_alpha(125)        index = 0        p1Index = 0        p2Index = 1        while selectPlayers:            for event in pygame.event.get():                if event.type == pygame.QUIT:                    pygame.quit()                    exit()                if event.type == pygame.KEYDOWN:                    keys = pygame.key.get_pressed()                    if keys[K_RIGHT]:                        p1Index += 1                    if keys[K_LEFT]:                        p1Index -= 1                    if keys[K_d]:                        p2Index += 1                    if keys[K_a]:                        p2Index -= 1                    if keys[K_RETURN]:                        p1Object = playersList[p1Index]                        p2Object = playersList[p2Index]                        selectPlayers = False                        break                    if keys[K_ESCAPE]:                        levelSelect(list, func)            if index >= len(lvlSelect_Anim) - 1:                index = 0                continue            else:                index += 1            bg = lvlSelect_Anim[index]            if p1Index > len(playersList) - 1:                p1Index = 0            if p1Index < 0:                p1Index = len(playersList) - 1            if p2Index > len(playersList) - 1:                p2Index = 0            if p2Index < 0:                p2Index = len(playersList) - 1            img1 = pygame.transform.scale(playersList[p1Index].image, win1Prev.get_size())            img2 = pygame.transform.scale(playersList[p2Index].image, win2Prev.get_size())            p1Name = Text(playersList[p1Index].name, (None, headerColor), font, (win1.get_width()//2, win1.get_height() * 2//3))            p2Name = Text(playersList[p2Index].name, (None, headerColor), font, (win2Rect.topleft[0] + win2.get_width()//2, win2.get_height() * 2//3))            win1Prev.blit(img1, (0, 0))            win2Prev.blit(img2, (0, 0))            screen.blit(bg, (0, 0))            screen.blit(win1, win1Rect)            screen.blit(win2, win2Rect)            screen.blit(win1Prev, prev1Rect)            screen.blit(win2Prev, prev2Rect)            screen.blit(p1Name.image, p1Name.rect)            screen.blit(p2Name.image, p2Name.rect)            screen.blit(playerSelect.image, playerSelect.rect)            screen.blit(player1.image, player1.rect)            screen.blit(player2.image, player2.rect)            scanlineGroup.draw(screen)            pygame.display.update()            clock.tick(30)        while run:            for event in pygame.event.get():                if event.type == pygame.QUIT:                    pygame.quit()                    exit()                if event.type == pygame.KEYDOWN:                    keys = pygame.key.get_pressed()                    if keys[K_ESCAPE]:                        levelSelect(list, func)                        break                    if keys[K_RETURN]:                        enterOpp()                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        pygame.mixer.music.load("songs/" + mainLevel.bgSong)                        pygame.mixer.music.play(-1)                        func(mainLevel, p1_state[itrRow[0]], p2_state[itrRow[1]], p1Object, p2Object)                        break                    if keys[K_DOWN]:                        row += 1                        break                    if keys[K_UP]:                        row -= 1                        break                    if keys[K_RIGHT]:                        itrRow[row] += 1                        break                    if keys[K_LEFT]:                        itrRow[row] -= 1                        break            if itrRow[row] < 0:                itrRow[row] = 1            if itrRow[row] > 1:                itrRow[row] = 0            if row < 0:                row = 1            elif row > 1:                row = 0            p1Rect.center = (screen.get_width() // 3, screen.get_height() // 2 - 10)            p2Rect.center = (screen.get_width() // 3, screen.get_height() // 2 + 10)            headerRect.center = (screen.get_width() // 2, screen.get_height() // 2 - 50)            p1OnRect.center = (screen.get_width() * 2 // 3, screen.get_height() // 2 - 10)            p2OnRect.center = (screen.get_width() * 2 // 3, screen.get_height() // 2 + 10)            p1OffRect.center = p1OnRect.center            p2OffRect.center = p2OnRect.center            if index >= len(lvlSelect_Anim) - 1:                index = 0                continue            else:                index += 1            bg = lvlSelect_Anim[index]            screen.blit(bg, (0, 0))            if p1_state[itrRow[0]]:                screen.blit(p1On, p1OnRect)            else:                screen.blit(p1Off, p1OffRect)            if p2_state[itrRow[1]]:                screen.blit(p2On, p2OnRect)            else:                screen.blit(p2Off, p2OffRect)            if row == 0:                cursorRect.midright = p1OnRect.midleft            elif row == 1:                cursorRect.midright = p2OnRect.midleft            screen.blit(p1, p1Rect)            screen.blit(p2, p2Rect)            screen.blit(cursor, cursorRect)            screen.blit(header, headerRect)            scanlineGroup.draw(screen)            pygame.display.update()            clock.tick(30)def generate_terrain(base_plat, surface=screen, platDir="ground", length=20, randval=(screen.get_height()*2//3, screen.get_height()*5//6)):    platgroup = pygame.sprite.Group()    platDecor = pygame.sprite.Group()    platgroup.add(base_plat)    for i in range(length):        tmp_plat = Platform(True, None, platDir, surface)        tmp_plat.rect.midleft = (platgroup.sprites()[-1].rect.midright[0] + 30, random.randint(randval[0], randval[1]))        platgroup.add(tmp_plat)    index = 0    for i in platgroup.sprites():        if index % 5 == 0 and index != 0:            tmp_dec = PlatDecorations(i, None, platDir, surface)            platDecor.add(tmp_dec)        index += 1    return (platgroup, platDecor)def test_level(level):    global platforms    global decorations    terrain_sprites = pygame.sprite.Group()    enemy_sprites = pygame.sprite.Group()    base_plat = Platform(True, image=("platforms/" + level.platDir + "/" + level.startblock))    base_plat.image = pygame.transform.scale(base_plat.image, (base_plat.image.get_width() * 3, base_plat.image.get_height() * 2))    base_plat.rect = base_plat.image.get_rect()    base_plat.rect.midleft = (0, screen.get_height())    testPlayer = Player(playersList[0])    testPlayer.jumpGame = True    testPlayer.rect.center = (screen.get_width()//2, 0)    players.add(testPlayer)    for sprite in platforms:        platforms.remove(sprite)        sprite.kill()    for decor in decorations:        decorations.remove(decor)        decor.kill()    level.loadBG(screen)    pygame.mixer.music.load("songs/indev_level.ogg")    pygame.mixer.music.play(-1)    terrain = generate_terrain(base_plat, screen, length=80, platDir=level.platDir)    allPlatforms, allDecors = terrain    lastPlat = Platform(True, image=("platforms/" + level.platDir + "/" + level.startblock))    lastPlat.image = pygame.transform.scale(lastPlat.image, (lastPlat.image.get_width() * 3, lastPlat.image.get_height() * 2))    lastPlat.rect = lastPlat.image.get_rect()    lastPlat.rect.midleft = (allPlatforms.sprites()[-1].rect.midright[0], base_plat.rect.midleft[1])    platforms.add(lastPlat)    tmp_enemy = Boss("overworldBoss", base_plat)    enemy_sprites.add(tmp_enemy)    terrain_sprites.add(testPlayer)    terrain_sprites.add(tmp_enemy)    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                key = pygame.key.get_pressed()                if key[K_ESCAPE]:                    for sprite in terrain_sprites:                        sprite.kill()                    platforms = pygame.sprite.Group()                    decorations = pygame.sprite.Group()                    players.remove(testPlayer)                    testPlayer.kill()                    startScreen()                    break        screen.blit(level.image, (0, 0))        players.update(level.jumpForce, level.gravity)        enemy_sprites.update()        decorations.update()        for decoration in allDecors.sprites():            if decoration.rect.midright[0] > -screen.get_width()//4 or decoration.rect.midleft[0] < screen.get_width() * 5//4:                decoration.add(decorations)                decoration.add(terrain_sprites)            else:                decorations.remove(decorations)                decorations.remove(terrain_sprites)        for plat in allPlatforms.sprites():            if plat.rect.midright[0] > -screen.get_width()//4 or plat.rect.midleft[0] < screen.get_width() * 5//4:                plat.add(platforms)                plat.add(terrain_sprites)            else:                plat.remove(platforms)                plat.remove(terrain_sprites)        if testPlayer.rect.midright[0] >= width * 5//6:            for sprite in terrain_sprites.sprites():                sprite.rect.centerx -= int(testPlayer.prevVel)        elif testPlayer.rect.midleft[0] <= width//6:            for sprite in terrain_sprites.sprites():                sprite.rect.centerx -= int(testPlayer.prevVel)        if testPlayer.rect.midtop[1] > screen.get_height() * 1.25:            gameOver()            break        terrain_sprites.draw(screen)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)# Needs work ....def playerSelect(playerList, songList):    playerIndex = 0    songIndex = 0def bonusMain(tmpLvl, distance=0, classicBool=False, player=dummy1):    for item in platforms:        item.remove(platforms)        item.kill()    for item in decorations:        item.remove(decorations)        item.kill()    for item in clouds:        item.remove(clouds)        item.kill()    enemyGroup = pygame.sprite.Group()    explosion = pygame.image.load("misc/explosion.png")    if tmpLvl.noBG:        tmpLvl.bg = None    if tmpLvl.bg != None:        tmpLvl.loadBG()    cloudsGroup2 = pygame.sprite.Group()    # Creating background clouds    if tmpLvl.cloud != None:        for i in range(40):            new_cloud = Clouds((random.randrange(0, width), random.randrange(0, height)), "backgroundObjects/" + tmpLvl.cloud)            if i > 20:                new_cloud.image.set_alpha(220)                new_cloud.speed = 2                clouds.add(new_cloud)            else:                new_cloud.speed = 1                new_cloud.image.set_alpha(165)                if not pygame.sprite.spritecollide(new_cloud, clouds, False):                    clouds.add(new_cloud)        for i in range(10):            new_cloud = Clouds((random.randrange(0, width), random.randrange(height * 2//3, height)), "backgroundObjects/" + tmpLvl.cloud, size=(225, 95))            new_cloud.image.set_alpha(128)            if not pygame.sprite.spritecollideany(new_cloud, cloudsGroup2):                cloudsGroup2.add(new_cloud)    if not classicBool:        pygame.mixer.music.load("songs/" + tmpLvl.bgSong)    else:        pygame.mixer.music.unload()        pygame.mixer.music.load("songs/classics/classic-0.ogg")    # Importing global variables    global PlayerSpeed    global CHANCE    global enemyFreq    PlayerSpeed = tmpLvl.psd    # defining player    p1 = Player(player[0])    all_sprites.add(p1)    players.add(p1)    p1.raceBool = True    p1.relpos.x = distance * FPS    # Defining ground platform    plat1 = Platform(True, "platforms/" + tmpLvl.platDir + '/' + tmpLvl.startblock)    # Customizing platform    if not classicBool:        plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 3, plat1.image.get_height() * 3))    else:        plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 6, plat1.image.get_height() * 6))    plat1.rect = plat1.image.get_rect()    plat1.rect.topleft = (50, height * 5 // 6 + 3)    plat2 = Platform(True, "platforms/" + tmpLvl.platDir + '/platform_0.png')    plat2.rect.center = (width * 1.25, height * 4 // 6)    # Add initial platform to groups    platforms.add(plat1)    all_sprites.add(plat1)    platforms.add(plat2)    all_sprites.add(plat2)    # loop the background music    pygame.mixer.music.play(-1)    platnum = 0    decor_plat = None    # Creating font object    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    index = 0    if tmpLvl.zoomMode:        bgBottomLeft = tmpLvl.rect.bottomleft[1] + 50    else:        if not classicBool:            bgBottomLeft = tmpLvl.rect.bottomleft[1]        else:            bgBottomLeft = screen.get_height()    countVal = 1500    checkMode = False    intensity = 1    while True:        # PlayerSpeed Text        ps1 = sub.render('Player Speed:', BG2, (55, 255, 55))        ps2 = sub.render(str(PlayerSpeed), BG2, (55, 255, 55))        # Rectangle        ps1Rect = ps1.get_rect()        ps2Rect = ps2.get_rect()        # Position        ps1Rect.center = (width * 6 // 16, ps1.get_height() * 3)        ps2Rect.center = (width * 11 // 16, ps2.get_height() * 3)        # HUD Player text        score1 = sub.render('Player Distance', BG2, (55, 255, 55))        score2 = sub.render(str(p1.relpos.x // FPS), BG2, (55, 255, 55))        # text rectangle        score1Rect = score1.get_rect()        score2Rect = score2.get_rect()        # Positioning text        score1Rect.center = (width * 6 // 16, score1.get_height() * 2)        score2Rect.center = (width * 11 // 16, score2.get_height() * 2)        # Window event handler        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        # Making the platforms move to create an illusion        # That the player is moving        for plat in platforms:            px, py = plat.rect.center            px -= PlayerSpeed            plat.rect.center = (px, py)        # Put in for loop for user to increase game intensity        for i in range(1):            # randomizing chance            # same logic as the seagull (l. 399) but with lava blocks            # but not dependent on distance            random.seed(datetime.now())            choice = random.randint(0, CHANCE)            if choice == 0:                new_plat = Platform(False, None, tmpLvl.platDir)                danger.add(new_plat)            else:                platnum += 1                new_plat = Platform(True, None, tmpLvl.platDir)                decor_plat = new_plat            # if platforms overlap            # remove them            if not pygame.sprite.spritecollide(new_plat, platforms, False):                platforms.add(new_plat)                all_sprites.add(new_plat)            else:                new_plat.kill()        # checking if the player died        # If it happened then reset settings and run gameOver method        if p1.rect.centery > height * 3//2 or pygame.sprite.spritecollide(p1, danger, False) or p1.rect.midright[0] < 0 or p1.image == explosion:            PlayerSpeed = tmpLvl.psd            CHANCE = 128            for item in decorations:                all_sprites.add(item)            for item in clouds:                all_sprites.add(item)            gameOver(classicBool=classicBool)        # if platform is out of screen or if there are more than 10 platforms then destroy        i = 0        for plat in platforms:            i += 1            px, py = plat.rect.topright            if px <= -50 or i > 10:                plat.kill()        # Seagull spawning after player distance 50000/FPS Rate        if p1.relpos.x > 50000:            # Chance of a seagull spawning            choice = random.randint(0, CHANCE)            # If true then spawn            if choice == 0:                for i in range(random.randrange(0, 3)):                    new_seagull = Seagull(tmpLvl.platDir)                    if not pygame.sprite.spritecollide(new_seagull, seagulls, False):                        seagulls.add(new_seagull)                        all_sprites.add(new_seagull)                        danger.add(new_seagull)        # When players score divided by factor number gives a remainder of 0.        # And if player score not zero its self        if p1.relpos.x % (countVal) // tmpLvl.factor == 0 and p1.relpos.x != 0:            PlayerSpeed += 1            countVal -= 50            if countVal <= 50:                countVal = 250            # 1/chancenumber divided by 1005/1000            CHANCE //= 1.005            if PlayerSpeed >= 16:                num = random.randint(enemyFreq[0], enemyFreq[1])                if enemyFreq[0] > enemyFreq[1]//2:                    enemyFreq[0] = 1                if num <= enemyFreq[0]:                    enemyFreq[0] += 1                    if classicBool:                        tmp = Player(enemy, True)                    else:                        tmp = Player(enemy2, True)                    tmp.rect.midright = (-20, screen.get_height() * 2//3)                    enemyGroup.add(tmp)                    danger.add(tmp)        if p1.relpos.x % (countVal * 10) // tmpLvl.factor == 0 and p1.relpos.x < 0:            intensity += 0.25        while len(enemyGroup.sprites()) > int(intensity):            tmp = enemyGroup.sprites()[-1]            tmp.remove(enemyGroup)            tmp.kill()        if not classicBool:            if platnum % 5 == 0:                new_decor = PlatDecorations(decor_plat, None, tmpLvl.platDir)                if pygame.sprite.spritecollide(new_decor, decorations, False):                    new_decor.kill()                else:                    decorations.add(new_decor)            for decor in decorations:                x, y = decor.rect.center                if x < 0 - screen.get_width() * 2:                    decor.image.set_alpha(0)                    decorations.remove(decor)                    decor.kill()        if p1.rect.centerx < width//3 or p1.rect.centerx > width * 2//3:            checkMode = True        if checkMode:            if p1.rect.centerx < width//2:                p1.rect.centerx += 1            elif p1.rect.centerx > width//2:                p1.rect.centerx -= 1            else:                checkMode = False        for opp in enemyGroup.sprites():            opp.rect.center = (opp.rect.center[0] + 2, opp.rect.center[1])            if opp.rect.midright[0] > width + 20:                opp.kill()        # Updating sprite groups        clouds.update()        cloudsGroup2.update(speed=PlayerSpeed+3, minHeight=height * 2//3)        seagulls.update()        enemyGroup.update(tmpLvl.jumpForce, tmpLvl.gravity, players)        p1.update(tmpLvl.jumpForce, tmpLvl.gravity)        # to cover glitchy sprites        screen.fill((0, 0, 0))        if not classicBool:            tmpLvl.rect.bottomleft = (int(index), int(bgBottomLeft))        if tmpLvl.bg != None:            screen.blit(tmpLvl.image, tmpLvl.rect)        else:            screen.fill(BG)        if not classicBool:            if p1.relpos.x // FPS % 600 == 0 and p1.relpos.x // FPS != 0:                pygame.mixer.music.stop()                pygame.mixer.music.unload()                pygame.mixer.music.load("songs/Extras/multiplayer.ogg")                pygame.mixer.music.play(-1)                distance = p1.relpos.x // FPS                info = [tmpLvl, distance, classicBool, player]                enterOpp(msg="A new opponent has arrived", fadeOut=False)                multiplayerDual(player, dummy2, info)        clouds.draw(screen)        if not classicBool:            decorations.update()            decorations.draw(screen)        # Drawing all sprites to screen        enemyGroup.draw(screen)        all_sprites.draw(screen)        cloudsGroup2.draw(screen)        screen.blit(score1, score1Rect)        screen.blit(score2, score2Rect)        screen.blit(ps1, ps1Rect)        screen.blit(ps2, ps2Rect)        scanlineGroup.draw(screen)# Refreshing screen        pygame.display.update()        if tmpLvl.zoomMode:            index -= 0.2            if bgBottomLeft < screen.get_height() * 2//3 + screen.get_height():                bgBottomLeft += 0.1            else:                bgBottomLeft -= 0.1        # Fixed Frame rate 110 recommended unless old computer        clock.tick(FPS)def multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object, mainBool=False, lvlList=None, itr=0):    aliens = pygame.sprite.Group()    numberGroup = pygame.sprite.Group()    random.seed(datetime.now())    # Importing global variables    global PlayerSpeed    global CHANCE    PlayerSpeed = PlayerSpeed + 1    line = pygame.Surface((width, 20))    line.fill((0, 0, 0))    line.set_alpha(200)    lineRect = line.get_rect()    lineRect.topleft = (0, height * 1 // 2 - 10)    # Split-screen    sc1 = pygame.Surface((width, height / 2))    sc2 = pygame.Surface((width, height / 2))    # Splitscreen rect    sc1Rect = sc1.get_rect()    sc2Rect = sc2.get_rect()    # Positioning screens    sc1Rect.topleft = (0, 0)    sc2Rect.topleft = (0, height / 2)    tmplvl.loadBG(screen.get_size())    # defining players    p1 = Player(surf=sc1, AIMode=p1Mode, playerObject=p1Object, player1Bool=True)    players.add(p1)    p1Tag = PlayerTag(p1, "1")    p2 = Player(surf=sc2, AIMode=p2Mode, playerObject=p2Object, player1Bool=False)    players.add(p2)    for player in players.sprites():        player.fuel = 0        if not player.AIMode:            player.raceBool = True    p2Tag = PlayerTag(p2, "2")    numberGroup.add(p1Tag)    numberGroup.add(p2Tag)    # Defining ground platform    plat1 = Platform(True, 'platforms/' + tmplvl.platDir + '/' + tmplvl.startblock, None, sc1)    # Customizing platform    plat1.rect.topleft = (sc1.get_width() * 0.5, sc1.get_height() * 5 // 6 + 3)    plat2 = Platform(True, 'platforms/' + tmplvl.platDir + '/platform_0.png', None, sc1)    plat2.image = pygame.transform.scale(plat2.image, (plat2.image.get_width() * 2 // 3, plat2.image.get_width() * 2 // 3))    plat2.rect = plat2.image.get_rect()    plat2.rect.center = (sc1.get_width() * 1.15, sc1.get_height() * 9 // 12)    # Add initial platform to groups    platforms.add(plat1)    all_sprites.add(plat1)    platforms.add(plat2)    all_sprites.add(plat2)    # Creating font object    header = pygame.font.Font('fonts/segaArt.ttf', 100)    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    numberFont = pygame.font.Font("fonts/ka1.ttf", 150)    numbers = [        numberFont.render("3", BG2, (255, 55, 25)),        numberFont.render("2", BG2, (252, 186, 3)),        numberFont.render("1", BG2, (55, 255, 25)),        numberFont.render("GO!", BG2, (155, 255, 155))    ]    line1 = Text("Player 1 / " + p1.name + ": ", BG_FG_Color=(None, (150, 250, 150)), script=sub, pos=(0, 0))    line2 = Text("Player 2 / " + p2.name + ": ", BG_FG_Color=(None, (150, 250, 150)), script=sub, pos=(0, 0))    line1.rect.topleft = (0, 0)    line2.rect.topleft = line1.rect.bottomleft    started = False    ended = False    winner = None    counter = 0    platnum = 0    decor_plat = None    countVal = 500    index = 0    while True:        counter += PlayerSpeed        PlayerSpeed = int(PlayerSpeed)        # PlayerSpeed And Distance Text        ps1 = sub.render('Player Speed:', BG2, (55, 255, 55))        ps2 = sub.render(str(PlayerSpeed), BG2, (55, 55, 255))        pd1 = sub.render('Player Distance:', BG2, (55, 255, 55))        pd2 = sub.render(str(counter // FPS), BG2, (55, 55, 255))        # Win dialog        win = header.render('You Win', BG2, (55, 55, 255))        # Rectangle        ps1Rect = ps1.get_rect()        ps2Rect = ps2.get_rect()        pd1Rect = pd1.get_rect()        pd2Rect = pd1.get_rect()        winRect = win.get_rect()        # Position        ps1Rect.center = (width * 6 // 16, ps1.get_height() * 2)        ps2Rect.center = (width * 11 // 16, ps2.get_height() * 2)        pd1Rect.center = (width * 6 // 16, pd1.get_height() * 3)        pd2Rect.center = (width * 13 // 16, pd2.get_height() * 3)        winRect.center = (width / 2, height / 2)        # Window event handler        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        #x, y = p1.rect.center        # Making the platforms move to create an illusion        # That the player is moving        for plat in platforms:            px, py = plat.rect.center            px -= PlayerSpeed            plat.rect.center = (px, py)        # Put in for loop for user to increase game intensity        for i in range(1):            new_plat = Platform(True, None, tmplvl.platDir, sc1)            new_plat.image = pygame.transform.scale(new_plat.image, (            new_plat.image.get_width() * 2 // 3, new_plat.image.get_height() * 2 // 3))            new_plat.rect = new_plat.image.get_rect()            new_plat.rect.center = (random.randrange(sc1.get_width() * 1.05, sc1.get_width() * 1.5), random.randrange(sc1.get_height() * 8 // 12, sc1.get_height() * 5 // 6))            # if platforms overlap            # remove them            if not pygame.sprite.spritecollide(new_plat, platforms, False):                platforms.add(new_plat)                all_sprites.add(new_plat)                platnum += 1                decor_plat = new_plat            else:                new_plat.kill()        if not ended and counter // FPS > 0:            for player in players.sprites():                x, y = player.rect.center                if y > sc1.get_height() * 2 or pygame.sprite.spritecollide(player, danger, False) or x < 0:                    delPlayer = player                    all_sprites.remove(delPlayer)                    players.remove(delPlayer)                    delPlayer.rect.bottomright = (0, 0)                    delPlayer.kill()                    break        if not ended:            if len(players.sprites()) < 2:                winner = players.sprites()[-1]                winner.AIMode = True                winner.raceBool = False                ended = True        else:            if PlayerSpeed > 2:                PlayerSpeed -= 0.07        # if platform is out of screen or if there are more than 10 platforms then destroy        i = 0        for plat in platforms:            i += 1            if plat.rect.topright[0] <= 0 or i > 10:                plat.kill()        # When players score divided by 100 gives a remainder of 0.        # And if player score is not zero its self        # In this case it's only used to increment the speed since this is a race.        if counter > 9000 and counter % (20 * 100) // tmplvl.factor == 0 and counter != 0:            alien = Seagull(tmplvl.platDir, sc1)            x, y = alien.rect.center            alien.rect.center = (x, random.randint(sc1.get_height() * 1 // 3, sc1.get_height() * 5 // 6))            if pygame.sprite.spritecollide(alien, aliens, False):                alien.kill()            else:                danger.add(alien)                aliens.add(alien)                all_sprites.add(alien)        if started:            if counter % (countVal) // tmplvl.factor == 0 and counter != 0:                PlayerSpeed += 1                countVal -= 50                if countVal <= 50:                    countVal = 250        # 1/chancenumber  = itself / 1.05        CHANCE //= 1.05        if platnum % 20 == 0 and platnum != 0:            new_decor = PlatDecorations(decor_plat, None, tmplvl.platDir)            if pygame.sprite.spritecollide(decor_plat, decorations, False):                new_decor.kill()            else:                decorations.add(new_decor)        for decor in decorations:            if decor.rect.midright[0] < 0 - screen.get_width() * 0.5:                decorations.remove(decor)                decor.kill()                break        for player in players.sprites():            player.update(tmplvl.jumpForce, tmplvl.gravity)            if player.AIMode:                player.raceBool = False        numberGroup.update()        decorations.update()        if started:            aliens.update()        sc1.fill((0, 0, 0))        sc2.fill((0, 0, 0))        sc1.blit(tmplvl.image1, tmplvl.rect1)        sc2.blit(tmplvl.image1, tmplvl.rect2)        decorations.draw(sc1)        decorations.draw(sc2)        sc1.blit(p1.image, p1.rect)        sc1.blit(p1Tag.image, p1Tag.rect)        sc2.blit(p2.image, p2.rect)        sc2.blit(p2Tag.image, p2Tag.rect)        # Drawing all sprites to screen        all_sprites.draw(sc1)        all_sprites.draw(sc2)        sc1.blit(line1.image, line1.rect)        sc2.blit(line2.image, line2.rect)        # Showing splitscreen        screen.blit(sc1, sc1Rect)        screen.blit(sc2, sc2Rect)        screen.blit(line, lineRect)        screen.blit(ps1, ps1Rect)        screen.blit(ps2, ps2Rect)        screen.blit(pd1, pd1Rect)        screen.blit(pd2, pd2Rect)        keys = pygame.key.get_pressed()        if not mainBool:            if keys[K_r]:                for sprite in decorations:                    all_sprites.add(sprite)                ended = False                sleep(0.5)                for sprite in all_sprites:                    sprite.kill()                CHANCE = 128                PlayerSpeed = PSD                multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object, mainBool, lvlList, itr)                startScreen()        if ended:            if winner.name == p1Object.name:                win2 = sub.render("Player 1", BG2, (55, 155, 255))            if winner.name == p2Object.name:                win2 = sub.render("Player 2", BG2, (55, 155, 255))            win2Rect = win2.get_rect()            win2Rect.center = (width // 2, height * 2 // 3)            screen.blit(win2, win2Rect)            screen.blit(win, winRect)            for sprite in decorations:                all_sprites.add(sprite)            if keys[K_RETURN]:                ended = False                sleep(0.5)                for sprite in all_sprites:                    sprite.kill()                CHANCE = 128                PlayerSpeed = PSD                winner.kill()                winner = None                enterOpp()                if not mainBool:                    startScreen()                else:                    pygame.mixer.music.stop()                    pygame.mixer.music.unload()                    pygame.mixer.music.load("songs/bg.ogg")                    pygame.mixer.music.play(-1)                    # main(levels, itr=itr, playerSpeed=0)            if keys[K_r]:                ended = False                sleep(0.5)                for sprite in all_sprites:                    sprite.kill()                CHANCE = 128                PlayerSpeed = PSD                winner.kill()                winner = None                multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object, mainBool, lvlList, itr)                startScreen()            if p1Pad != None or p2Pad != None:                if p1Pad.get_button(1):                    ended = False                    sleep(0.5)                    for sprite in all_sprites:                        sprite.kill()                    CHANCE = 128                    PlayerSpeed = PSD                    winner.kill()                    winner = None                    enterOpp()                    startScreen()                if p1Pad.get_button(9):                    ended = False                    sleep(0.5)                    for sprite in all_sprites:                        sprite.kill()                    CHANCE = 128                    PlayerSpeed = PSD                    winner.kill()                    winner = None                    multiplayer(tmplvl, p1Mode, p2Mode, p1Object, p2Object, mainBool, lvlList, itr)                    startScreen()        if not started:            if index >= len(numbers) - 1:                PlayerSpeed = 6            else:                PlayerSpeed = 0            if pygame.sprite.spritecollideany(p1, platforms) or pygame.sprite.spritecollideany(p2, platforms):                if index >= len(numbers):                    index = 0                    started = True                    continue                tmpNum = numbers[int(index)]                numRect = tmpNum.get_rect()                numRect.center = (screen.get_width()//2, screen.get_height()//2)                screen.blit(tmpNum, numRect)                index += 0.01        scanlineGroup.draw(screen)        # Refreshing screen        pygame.display.update()        # Fixed Frame rate 110 recommended unless old computer        clock.tick(FPS)def helpScreen():    pygame.mixer.music.load('songs/help.ogg')    headerFont = pygame.font.Font('fonts/pixelart.ttf', 50)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    fontColor = (245, 245, 245)    Title = Text("Manual", (None, fontColor), headerFont, (0, 0))    Title.rect.topleft = (60, 30)    f = open("files/help.txt", "r")    fList = f.readlines()    f.close()    index = 0    firstLine = Text(fList[0],(None, fontColor), sub, (0, 0))    firstLine.rect.topleft = Title.rect.bottomleft    lines = [firstLine]    pygame.mixer.music.play(-1)    for line in fList:        if line == firstLine:            continue        tmpLine = Text(line, (None, fontColor), sub, (0, 0))        tmpLine.rect.midtop = lines[index].rect.midbottom        lines.append(tmpLine)        index += 1    y = firstLine.rect.topleft[1]    gif_index = 0    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_DOWN]:                    if lines[0].rect.topleft[1] < Title.rect.bottomleft[1]:                        y += 20 * 5                if keys[K_UP]:                    if lines[-1].rect.bottomleft[1] > screen.get_height() * 2//3:                        y -= 20 * 5                if keys[K_ESCAPE]:                    enterOpp()                    startScreen()                    exit()        firstLine.rect.topleft = (firstLine.rect.topleft[0], y)        index = 0        for line in lines:            if line == firstLine:                continue            line.rect.midtop = lines[index].rect.midbottom            index += 1        if gif_index >= len(help_bg) - 1:            gif_index = 0        else:            gif_index += 1        screen.blit(help_bg[gif_index], (0, 0))        for line in lines:            screen.blit(line.image, line.rect)        screen.blit(Title.image, Title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def introScreen():    font = pygame.font.Font("fonts/segaArt.ttf", 125)    font2 = pygame.font.Font("fonts/pixelart.ttf", 125)    logo = font2.render("A2", None, (218, 235, 33))    logo2 = font.render(" Games", None, (218, 235, 33))    logoRect = logo.get_rect()    logo2Rect = logo2.get_rect()    logo2Rect.topleft = (width * 5 // 16, height / 2)    logoRect.topright = logo2Rect.topleft    i = 0    for i in range(255):        screen.fill((0, 0, 0))        screen.blit(logo, logoRect)        screen.blit(logo2, logo2Rect)        logo2.set_alpha(i)        logo.set_alpha(i)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)    sleep(0.5)    while i > 0:        screen.fill((0, 0, 0))        screen.blit(logo, logoRect)        screen.blit(logo2, logo2Rect)        logo.set_alpha(i)        logo2.set_alpha(i)        i -= 1        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)def enterOpp(surf=screen, font="fonts/headkick.ttf", msg=None, fadeOut=True):    win = pygame.Surface(surf.get_size())    win.fill((255, 255, 255))    alphaVal = 0    script = pygame.font.Font(font, 50)    if msg != None:        mesg = Text(msg, (None, (0, 0, 0)), script, (screen.get_width()//2, screen.get_height()//2))    while alphaVal < 220:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()        if fadeOut:            pygame.mixer.music.set_volume(pygame.mixer.music.get_volume()-0.01)            if pygame.mixer.music.get_volume() < 0.03:                break        win.set_alpha(alphaVal)        screen.blit(win, (0, 0))        if msg != None:            screen.blit(mesg.image, mesg.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)        alphaVal += 1    pygame.mixer.music.set_volume(1)def startScreen():    COLOR = (245, 245, 245)    pygame.mixer.music.load('songs/startups/startup.ogg')    header1 = pygame.font.Font('fonts/pixelart.ttf', 75)    header2 = pygame.font.Font('fonts/pixelart.ttf', 50)    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    title = header2.render(name, BG2, COLOR)    start = sub.render('Arcade', BG2, COLOR)    multi = sub.render('Multiplayer', BG2, COLOR)    help = sub.render('Help', BG2, COLOR)    exit = sub.render('Quit', BG2, COLOR)    cursor = sub.render('->', BG2, (100, 255, 100))    bonus = Text("Bonus", (None, COLOR), sub, (0, 0))    indev = Text("Sound Test", (None, COLOR), sub, (0, 0))    menuText = Text("Menu", (None, COLOR), header1, (0, 0))    titleRect = title.get_rect()    startRect = start.get_rect()    multiRect = multi.get_rect()    helpRect = help.get_rect()    exitRect = exit.get_rect()    cursorRect = cursor.get_rect()    titleRect.center = (width/2, height * 1 // 2)    startRect.center = (width/2, height * 1 // 2 - 10)    multiRect.center = (width/2, height * 1 // 2 + 10)    helpRect.center = (width/2, height * 1 // 2 + 30)    bonus.rect.center = (width/2, height * 1//2 + 50)    indev.rect.center = (width/2, height * 1//2 + 70)    exitRect.center = (width/2, height * 1//2 + 90)    menuText.rect.center = (width//2, height//3)    cursorRect.center = (width // 2 - 50, height * 1 // 2 - 10)    x, y = cursorRect.center    sx, sy = startRect.midleft    hx, hy = helpRect.midleft    ex, ey = exitRect.midleft    mx, my = multiRect.midleft    global multiBool    global firstEntry    pygame.mixer.music.play(-1, 1)    scanlines()    global Exit    index = 0    while not Exit:        for event in pygame.event.get():            key = pygame.key.get_pressed()            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                Exit = True        if index >= len(startup_1) - 1:            index = 0            continue        else:            index += 1        bg = startup_1[index]        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(title, titleRect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(10)    titleRect.center = (width / 2, height * 1 // 3)    index = 0    while True:        for event in pygame.event.get():            key = pygame.key.get_pressed()            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == KEYDOWN or event.type == pygame.JOYBUTTONDOWN or event.type == pygame.JOYAXISMOTION:                if key[K_UP]:                    y -= 20                if key[K_DOWN]:                    y += 20                if key[K_p]:                    pygame.mixer.quit()                if key[K_u]:                    pygame.mixer.init()                if key[K_RETURN] or key[K_SPACE]:                    for sprite in all_sprites:                        sprite.remove(all_sprites)                        sprite.kill()                    for sprite in danger:                        sprite.remove(danger)                        sprite.kill()                    enterOpp()                    if y == ey:                        pygame.mixer.music.stop()                        pygame.quit()                        sys.exit()                    elif y == hy:                        pygame.mixer.music.stop()                        firstEntry = False                        helpScreen()                        startScreen()                    elif y == my:                        multiBool = True                        firstEntry = False                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        pygame.mixer.music.load("songs/Extras/menu.ogg")                        pygame.mixer.music.play(-1)                        levelSelect(multiplayerLevels, multiplayer)                        break                    elif y == sy:                        multiBool = False                        firstEntry = False                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        if not arcadeLSelect:                            bonusMain(levels[random.randint(0, len(levels)-1)])                        else:                            pygame.mixer.music.load("songs/Extras/menu.ogg")                            pygame.mixer.music.play(-1)                            levelSelect(levels, bonusMain)                        break                    elif y == bonus.rect.midleft[1]:                        firstEntry = False                        multiBool = False                        if bonusUnlocked:                            pygame.mixer.music.stop()                            pygame.mixer.music.unload()                            bonusStartScreen()                            break                        else:                            continue                    elif y == indev.rect.midleft[1]:                        firstEntry = False                        multiBool = False                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        '''                        pygame.mixer.music.load("songs/Extras/multiplayer.ogg")                        pygame.mixer.music.play(-1)                        multiplayerDual(dummy1, dummy2)                        '''                        test_level(levels[-3])                        break                if y == ey:                    x = ex - 20                elif y == hy:                    x = hx - 20                elif y == sy:                    x = sx - 20                elif y == my:                    x = mx - 20                elif y == bonus.rect.midleft[1]:                    x = bonus.rect.midleft[0] - 20                elif y == indev.rect.midleft[1]:                    x = indev.rect.midleft[0] - 20                if y > ey:                    y = sy                    x = startRect.midleft[0] - 20                if y < sy:                    y = ey                    x = ex - 20        if index >= len(startup_2) - 1:            index = 0            continue        else:            index += 1        bg = startup_2[index]        cursorRect.center = (x, y)        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(menuText.image, menuText.rect)        screen.blit(start, startRect)        screen.blit(multi, multiRect)        screen.blit(exit, exitRect)        screen.blit(help, helpRect)        screen.blit(cursor, cursorRect)        screen.blit(bonus.image, bonus.rect)        screen.blit(indev.image, indev.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(10)def gameOver(player=None, classicBool=False):    if not classicBool:        if player != None:            player.remove(players)            player.kill()    pygame.mixer.music.load('sounds/gameOver.ogg')    pygame.mixer.music.stop()    header = pygame.font.Font('fonts/pixelart.ttf', 40)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    text = header.render('Game Over', BG, (255, 255, 255))    text2 = sub.render('Press anything to continue', BG, (255, 255, 255))    textRect = text.get_rect()    text2Rect = text2.get_rect()    textRect.midbottom = (width // 2, height // 3)    text2Rect.midbottom = (width // 2, height * 3 // 6)    screen.blit(text, textRect)    screen.blit(text2, text2Rect)    pygame.mixer.music.play(0, 0)    pygame.display.flip()    while True:        for event in pygame.event.get():            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                sleep(0.25)                for sprite in all_sprites:                    sprite.kill()                if not classicBool:                    enterOpp()                    startScreen()                else:                    bonusStartScreen()                break            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        scanlineGroup.draw(screen)        pygame.display.flip()if not debug:    introScreen()startScreen()