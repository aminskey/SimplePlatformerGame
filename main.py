# full importsimport numbersfrom typing import Listimport pygame, sys, random, cv2# import specific methodsfrom pygame.locals import *from datetime import datetimefrom time import sleepfrom warnings import filterwarningsfrom os import listdirfrom os.path import isdirfrom sys import exitfrom pygame.math import Vector2# filter warningfilterwarnings('ignore', category=DeprecationWarning)# initiate sound and graphicspygame.mixer.init()pygame.init()# Create FPS handlerclock = pygame.time.Clock()# Resolutionwidth = 900height = 700# joystickgameIcon = pygame.image.load("icons/gameIcon.png")pygame.display.set_icon(gameIcon)p1Pad = Nonep2Pad = Noneif pygame.joystick.get_count() > 0:    p1Pad = pygame.joystick.Joystick(0)    p1Pad.init()if pygame.joystick.get_count() > 1:    p2Pad = pygame.joystick.Joystick(0)    p2Pad.init()    p1Pad = pygame.joystick.Joystick(1)    p1Pad.init()# resolution tupleres = (width, height)firstEntry = True# Game namename = 'Sky Dash Adventures'subtitle = 'Project Genesis'# Setting up windowscreen = pygame.display.set_mode(res, FULLSCREEN | SCALED)pygame.display.set_caption(name)# Sprite Groupsclouds = pygame.sprite.Group()platforms = pygame.sprite.Group()all_sprites = pygame.sprite.Group()danger = pygame.sprite.Group()players = pygame.sprite.Group()seagulls = pygame.sprite.Group()decorations = pygame.sprite.Group()scanlineGroup = pygame.sprite.Group()projGroup = pygame.sprite.Group()bossGroup = pygame.sprite.Group()# text and screen backgroundBG = (52, 164, 235)BG2 = (100, 100, 255)RED = (255, 0, 0)YELLOW = (255, 255, 0)BLUE = (0, 0, 255)GREEN = (0, 255, 0)BLACK = (0, 0, 0)# Invisible mousepygame.mouse.set_visible(False)# Initial Player speedPSD = 4# player speedPlayerSpeed = PSDMAXCHANCE = 32CHANCE = MAXCHANCE# 1/32 = 3.125% chance of lava blockFPS = 50# Calculating Players position relative to startvec = pygame.math.Vector2# extrasdebug = TruescanlineBool = TruemultiBool = Falseended = False# for startscreenExit = FalsemaxSeqLen = 5# Clouds Classclass Clouds(pygame.sprite.Sprite):    # General settings    def __init__(self, pos, img="backgroundObjects/cloud.png", size=(150, 63), speed=2):        super().__init__()        self.image = pygame.image.load(img)        self.image = pygame.transform.scale(self.image, size)        self.rect = self.image.get_rect()        self.rect.center = pos        self.speed = speed    # Make them move in the air    def update(self, minHeight=0, speed=None):        x, y = self.rect.center        # if out of window then respawn ahead of widthspan        if x < -self.image.get_width() - 10:            random.seed(datetime.now())            x = width + self.image.get_width() + 10            y = random.randrange(minHeight, height)        # slowly drift backwards creating virtual effect        if speed == None:            x -= self.speed        else:            x -= speed        self.rect.center = (x, y)# platform classclass Platform(pygame.sprite.Sprite):    # initial settings    # asking Program if landable    def __init__(self, Landable, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        width, height = surface.get_size()        # if there is no specific image then use random        # if not landable then use lava block image.        if image == None:            plat_dir = listdir('platforms/' + dir)            bad_dir = listdir('badObjects/' + dir)            plat_max_len = len(plat_dir) - 1            bad_max_len = len(bad_dir) - 1            for item in plat_dir:                if isdir(item):                    plat_max_len -= 1            for item in bad_dir:                if isdir(item):                    bad_max_len -= 1            if Landable:                self.image = pygame.image.load(                    'platforms/' + dir + '/platform_' + str(random.randint(0, plat_max_len)) + '.png')            else:                self.image = pygame.image.load(                    'badObjects/' + dir + '/badplat' + str(random.randint(0, bad_max_len - 1)) + '.png')        else:            self.image = pygame.image.load(image)        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        # General settings        self.rect = self.image.get_rect()        self.rect.midleft = (width, random.randrange(height * 8 // 12, height * 5 // 6))    # self.pos = vec((self.rect.center))# Seagulls classclass Seagull(pygame.sprite.Sprite):    # initial settings    def __init__(self, dir="ground", surface=screen, image=None):        super().__init__()        width, height = surface.get_size()        if image == None:            self.image = pygame.image.load('badObjects/' + dir + '/air/seagull.png')        else:            self.image = pygame.image.load(image)        self.rect = self.image.get_rect()        self.rect.center = (random.randint(width, width * 2), random.randint(0, height * 5 // 24))        self.x, self.y = self.rect.center    # Update mechanism    def update(self):        self.x -= PlayerSpeed * 1.15        self.rect.center = (self.x, self.y)        if pygame.sprite.spritecollide(self, players, False):            self.image = pygame.image.load("misc/explosion.png")            self.rect = self.image.get_rect()            self.rect.center = (self.x, self.y)        # if seagull is out of screen then kill it        if self.rect.midright[0] < 0:            all_sprites.remove(self)            danger.remove(self)            seagulls.remove(self)            self.kill()class PlayerObject():    def __init__(self, name, sizeFactor, normalSize=False):        self.name = name        self.normalSize = normalSize        if not multiBool:            self.sideLength = 40        else:            self.sideLength = 35        self.sizeFactor = sizeFactor        self.image = pygame.image.load("players/"+name+".png")class Projectile(pygame.sprite.Sprite):    def __init__(self, pos, image="misc/fireball.png", size=1, direction=1, soundeffect=None):        super().__init__()        self.image = pygame.image.load(image)        self.image = pygame.transform.scale(self.image, (self.image.get_width()*size, self.image.get_height()*size))        self.rect = self.image.get_rect()        self.sender = None        self.rect.center = pos        self.pos = pos        self.damage = 0.05        self.counter = 0        self.max = 25        self.direction = direction        if soundeffect:            pygame.mixer.Sound(soundeffect).play()    def update(self):        self.counter += float(abs(self.direction))        self.rect.centerx += self.image.get_width()//2 * self.direction        if self.counter >= self.max:            self.remove(projGroup)            self.kill()# Player classclass Player(pygame.sprite.Sprite):    # initial settings    def __init__(self, playerObject, AIMode=False, surf=screen, player1Bool=True, raceMode=False):        super().__init__()        self.sideLength = playerObject.sideLength        # Temporary variable only used inside __init__ method        sizeFactor = playerObject.sizeFactor        self.image = playerObject.image        if not playerObject.normalSize:            self.image = pygame.transform.scale(self.image, (self.sideLength // sizeFactor, self.sideLength // sizeFactor))        self.blownup = pygame.image.load("misc/explosion.png")        self.rect = self.image.get_rect()        self.rect.center = (width // 2, 0)        self.health = 3        self.bossMode = False        self.acc = 0        self.relpos = vec(self.rect.center)        self.name = playerObject.name        self.jumpstate = True        self.dead = False        self.AIMode = AIMode        self.jumpGame = False        self.moveBools = [False, False]        if self.AIMode:            self.jumpstate = False        self.vel = 0        self.prevVel = 0        self.rectify_pos = False        # Can use powerups True|False        self.powerUpBool = True        self.powerUps = []        self.player1Bool = player1Bool        self.fric = -0.30        self.screen = surf        self.raceBool = raceMode        self.raceSpeed = 2        self.canMove = True        # Variables that make the sprite compatible with boss levels. In this case the sprite is the boss        self.damage = 0        self.delay = 100        self.regjump = True        self.enemy = None        self.destructive_enemy = False    def fire(self):        proj = Projectile((self.rect.midright[0] + 20, self.rect.midright[1]))        proj.sender = self        proj.add(projGroup)    def race(self, keys):        if self.rect.centerx <= width * 11//12:            if self.player1Bool:                if keys[K_RIGHT]:                    self.rect.centerx += 2                if keys[K_LEFT]:                    self.rect.centerx -= 2            else:                if keys[K_d]:                    self.vel += 2                if keys[K_a]:                    self.vel -= 2    def move(self, keys):        if self.player1Bool:            if keys[K_RIGHT]:                self.vel += PSD//4            if keys[K_LEFT]:                self.vel -= PSD//4        else:            if keys[K_d]:                self.vel += PSD//4            if keys[K_a]:                self.vel -= PSD//4        if self.vel >= PSD * 3:            self.vel = PSD * 3        elif self.vel <= -PSD * 3:            self.vel = -PSD * 3        if self.rect.midright[0] > width * 5//6:            # self.rect.midright = (width * 5//6, self.rect.midright[1])            self.rect.midright = (self.rect.midright[0] + self.vel, self.rect.midright[1])            # self.vel -= 1        elif self.rect.midleft[0] < width//6:            # self.rect.midleft = (width//6, self.rect.midleft[1])            self.rect.midleft = (self.rect.midleft[0] + self.vel, self.rect.midleft[1])            # self.vel += 1        else:            if self.vel != 0:                self.prevVel = self.vel            if self.vel < 0:                self.rect.centerx += self.vel - self.fric            if self.vel > 0:                self.rect.centerx += self.vel + self.fric            self.moveBools = [False, False]        if pygame.sprite.spritecollideany(self, platforms):            if self.vel < 0:                self.vel -= self.fric            if self.vel > 0:                self.vel += self.fric    # Jump mechanism    def jump(self, keys, jumpForce=20):        x, y = self.rect.center        # Event handling        if not self.AIMode:            if self.player1Bool:                if keys[K_SPACE]:                    # jumping                    y -= jumpForce            else:                if keys[K_w]:                    y -= jumpForce            if p1Pad != None:                if p1Pad.get_button(0):                    y -= jumpForce        else:            y -= jumpForce        # Updating position        self.rect.center = (x, y)    def AI(self):        if width * 4 // 6 >= self.rect.centerx > width // 6:            if self.raceBool and self.canMove:                oppGroup = pygame.sprite.Group()                oppGroup.add(self.enemy)                if pygame.sprite.spritecollideany(self, oppGroup):                    if not self.destructive_enemy:                        if self.jumpstate == True:                            self.jumpstate = False                        else:                            self.jumpstate = True                    else:                         self.enemy.health -= 1                    self.rect.centerx -= 5                if self.enemy.rect.centerx > self.rect.centerx - 100 or self.enemy.rect.centerx < self.rect.centerx + 100:                    self.rect.centerx += self.raceSpeed                else:                    self.rect.centerx += self.raceSpeed * 2        else:            self.canMove = False        if self.rect.centerx <= width * 3 // 6:            self.canMove = True        if pygame.sprite.spritecollideany(self, projGroup):            self.jumpstate = True            if self.rect.centerx > width//3:                self.rect.centerx -= 8        elif pygame.sprite.spritecollideany(self, platforms):            self.jumpstate = False            if self.raceBool:                if self.rect.centerx < self.enemy.rect.centerx - 50:                    self.fire()            collided_platform = pygame.sprite.spritecollide(self, platforms, False)[-1]            next_platform = None            # Calculate index number for collided platform            index = 0            for plat in platforms.sprites():                if plat == collided_platform:                    try:                        next_platform = platforms.sprites()[index + 1]                        break                    except IndexError:                        next_platform = platforms.sprites()[index]                    break                index += 1            distance = (next_platform.rect.midleft[0] - collided_platform.rect.midright[0])            if distance <= 80 and self.rect.centery <= collided_platform.rect.midtop[0]:                self.jumpstate = False            elif distance <= 200 and self.rect.centery <= collided_platform.rect.midtop[0]:                if self.rect.y <= 10:                    self.jumpstate = False            elif self.rect.centerx >= collided_platform.rect.midright[0] or self.rect.centery >= collided_platform.rect.midtop[1]:                self.jumpstate = True    # Gravity mechanics    def gravity(self, gravityDecimal=0.5):        x, y = self.rect.center        # checking for collision        # If not then continue falling and updating position        if not pygame.sprite.spritecollide(self, platforms, False):            y += self.acc            self.acc += gravityDecimal            self.rect.center = (x, y)        # else stop and update position        else:            self.acc = 0            self.rect.center = (x, y)    # The Update mechanism    def update(self, jumpForce=20, gravity=0.5, otherGroup=danger, sender=None):        x, y = self.rect.midtop        keys = pygame.key.get_pressed()        # Updating Position        self.rect.midtop = (x, y)        if pygame.sprite.spritecollideany(self, platforms):            currPlat = pygame.sprite.spritecollide(self, platforms, False)[-1]            self.jumpstate = True            if self.rect.midtop[1] < currPlat.rect.midtop[1] and self.rect.centery > currPlat.rect.midtop[1]:                self.rect.centery = currPlat.rect.midtop[1]            elif self.rect.midtop[1] > currPlat.rect.midtop[1]:                if self.rect.centerx > currPlat.rect.midleft[0] and self.rect.centerx < currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midleft[0]                elif self.rect.centerx < currPlat.rect.midright[0] and self.rect.centerx > currPlat.rect.centerx:                    self.rect.centerx = currPlat.rect.midright[0]        # Updating relative position        self.relpos.x += PlayerSpeed        if self.jumpGame:            self.move(keys)        if self.race and not self.AIMode:            self.race(keys)        if self.AIMode:            self.AI()        else:            if keys[K_x]:                sleep(0.005)                self.fire()        # If not in air allow jump mechanism        if self.jumpstate:            self.jump(keys, jumpForce)        # Running virtual gravity method        self.gravity(gravity)        if not self.regjump and self.AIMode:            self.jumpstate = False        if pygame.sprite.spritecollide(self, otherGroup, False):            if self.health <= 0:                self.image = pygame.image.load("misc/explosion.png")                self.image = pygame.transform.scale(self.image, (100, 100))                self.rect = self.image.get_rect()                self.rect.midtop = (x, y)                if self.AIMode:                    self.kill()            else:                self.health -= 0.05                self.jumpstate = True        if pygame.sprite.spritecollideany(self, projGroup):            proj = pygame.sprite.spritecollideany(self, projGroup)            if otherGroup.has(proj.sender):                self.health -= 1                proj.kill()class Boss(pygame.sprite.Sprite):    def __init__(self, name, fuel, delay=100):        super().__init__()        self.name = name        self.neutral = self.return_state_image("neutral")        self.image = self.neutral        self.rect = self.image.get_rect()        self.health = 9        self.acc_y = 0        self.max_gravity_acceleration = 10        self.jumpstate = False        self.enemy = None  # Sprite object        self.fuel = fuel        self.damage = 1.5        self.delay = delay        self.boundaries = [            screen.get_width()//6,            screen.get_width()//2,            screen.get_width()        ]        self.counter = 0    def gravity(self, acceleration=0.5):        self.rect.centery += self.acc_y        if self.acc_y < self.max_gravity_acceleration:            self.acc_y += acceleration    def jump(self, force=10):        if not self.jumpstate:            self.acc_y = -force            self.jumpstate = True    def return_state_image(self, state):        state = pygame.image.load("bosses/" + self.name + "/" + self.name + "-" + state + ".png")        return state    def fire(self, image="misc/fireball.png", direction=1, size=1, pos=(0, 0), max=5, soundeffect=None):        proj = Projectile(pos, image, size, direction, soundeffect)        proj.sender = self        proj.max = max        projGroup.add(proj)        self.fuel -= 1    def update(self):        if pygame.sprite.spritecollideany(self, projGroup):            proj = pygame.sprite.spritecollideany(self, projGroup)            if players.has(proj.sender):                self.health -= self.damage                pygame.mixer.Sound("sounds/pop.wav").play()        if self.health <= 0:            self.image = pygame.transform.scale(pygame.image.load("misc/explosion.png"), res)class Guard_01(Boss):    def __init__(self):        super().__init__("B-01", 1, 1750)        self.up_img = self.return_state_image("up")        self.down_img = self.return_state_image("down")        self.small_img = self.return_state_image("small")        self.entrance_mode = True        self.speed = 6        self.rect.topright = (0, 0)        self.full = True        self.max_delay = 15        self.shot_delay = self.max_delay        self.damage = 0.025        self.health = 9        self.counter = 0        self.dist = None        self.started_playing = False        self.sounds = [            pygame.mixer.Sound("sounds/jet-1.wav"),            pygame.mixer.Sound("sounds/jet-2.wav")        ]        for sound in self.sounds:            sound.play()    def entrance(self):            if self.rect.midleft[0] > screen.get_width():                self.rect.center = (screen.get_width()*3, screen.get_height()//2)                self.entrance_mode = False            self.rect.centerx += self.speed * 4    def AI(self):        # distance from shooting range: player + 150 units (x-coordinates)        self.dist = (self.rect.midleft[0] - (self.enemy.rect.centerx), self.rect.midleft[1] - self.enemy.rect.centery)        if self.full:            self.counter = 0            if self.dist[0] <= 500:                if self.rect.centery < self.enemy.rect.centery - 50:                    self.rect.centery += self.speed                if self.rect.centery > self.enemy.rect.centery - 50:                    self.rect.centery -= self.speed                if abs(self.dist[1]) < 200:                    if self.shot_delay <= 0:                        self.fire("misc/lazer.png", -0.2, 3, (self.rect.midleft[0] + 10, self.rect.midleft[1] - 50), max=20, soundeffect="sounds/lazer_fire.wav")                        self.shot_delay = self.max_delay                    else:                        self.shot_delay -= 0.55            else:                self.rect.centerx -= self.speed//2        else:            if self.counter == 0:                snd = pygame.mixer.Sound("sounds/charge.wav")                snd.play()            if self.counter % 50 == 0:                self.rect.centerx += 1            self.counter += 1    def update(self):        if not self.full:            if self.fuel <= 10:                self.fuel += 0.015            else:                self.full = True        if self.fuel <= 0:            self.full = False        if self.entrance_mode:            self.entrance()        else:            self.AI()        if self.health <= 0:            for sound in self.sounds:                sound.stop()        super().update()class Rampager(Boss):    def __init__(self):        super().__init__("rampager", 20)        self.boost_image = self.return_state_image("boost")        self.rect.midright = screen.get_rect().midleft    def AI(self):        if self.fuel >= 0:            self.image = self.neutral            if self.rect.midright[0] < self.enemy.rect.midleft[0] - 150:                self.rect.centerx += 2            else:                if self.rect.midleft[0] < screen.get_width():                    if self.enemy.rect.centerx > self.rect.midright[0]:                        sleep(0.00005)                        self.fire(size=10, pos=self.rect.midright, soundeffect="sounds/flame.wav")                else:                    self.rect.centerx -= 2        else:            self.boost()            if self.fuel < 150:                self.fuel += 0.0025            elif self.health < 5:                self.fire(size=10, pos=self.rect.midright, soundeffect="sounds/flame.wav")    def boost(self):        if self.image == self.neutral:            self.image = self.boost_image            self.rect.midright = self.rect.center        self.rect.centerx += 5    def update(self):        if not pygame.sprite.spritecollideany(self, platforms):            self.gravity()        else:            plat = pygame.sprite.spritecollideany(self, platforms)            if self.rect.centery >= plat.rect.midtop[1]:                self.jumpstate = False        self.AI()        self.jump()        self.rect.centerx -= 1        super().update()class PlatDecorations(pygame.sprite.Sprite):    def __init__(self, platform, image=None, dir="ground", surface=screen, sizeFactor=1):        super().__init__()        self.ok = True        if image != None:            self.image = pygame.image.load(image)        else:            decor_max_len = len(listdir('decorations/' + dir)) - 1            self.image = pygame.image.load(                'decorations/' + dir + '/decor_' + str(random.randint(0, decor_max_len)) + '.png')        if sizeFactor != 1:            self.image = pygame.transform.scale(self.image, (            self.image.get_width() // sizeFactor, self.image.get_height() // sizeFactor))        if platform == None:            print("Cannot summon decoration, specified platform is None")            self.ok = False        self.rect = self.image.get_rect()        self.platform = platform        self.surface = surface    def update(self):        self.rect.midbottom = self.platform.rect.midtop        if self.rect.center[0] < 0:            self.kill()class PlayerTag(pygame.sprite.Sprite):    def __init__(self, player, number):        super().__init__()        font = pygame.font.Font("fonts/pixelart.ttf", 40)        self.image = font.render(number, BG2, (55, 255, 55))        self.num = number        self.player = player        self.rect = self.image.get_rect()        self.rect.midbottom = self.player.rect.midtop    def update(self):        self.rect.midbottom = self.player.rect.midtop        if not self.player:            self.kill()# Levels Classclass Level():    def __init__(self, bg, spriteDirs, song, startblock, factor=1, playerStartSpeed=PSD, moveBool=False, gravity=0.5, jumpForce=20, name="Unknown Level", diff="easy", zoomMode=False, boss=None, acc=1):        self.bg = bg        self.factor = factor        self.diff = diff        self.name = name        self.acc = acc        self.zoomMode = zoomMode        if self.bg != None:            self.noBG = False            self.bg = "backgrounds/" + bg        else:            self.noBG = True            self.bg = "backgrounds/Unknown.png"        self.bgSong = song        self.length = 2500        self.fl = 2000        self.platDir, self.cloud = spriteDirs        self.jumpForce = jumpForce        self.gravity = gravity        self.psd = playerStartSpeed        self.moveBool = moveBool        self.startblock = startblock        self.boss = boss    def loadBG(self, res):        self.image = pygame.image.load(self.bg)        if self.zoomMode:            self.image = pygame.transform.scale(self.image, (res[0]*2, res[1]*2)).convert()        else:            self.image = pygame.transform.scale(self.image, res)        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, res[1])class Line(pygame.sprite.Sprite):    def __init__(self, thickness, alpha, color, pos, length=screen.get_width()):        super().__init__()        self.alpha = alpha        self.image = pygame.Surface((length, thickness))        self.image.fill(color)        self.image.set_alpha(self.alpha)        self.rect = self.image.get_rect()        self.rect.topleft = posclass Text(pygame.sprite.Sprite):    def __init__(self, str, BG_FG_Color, script, pos=(0,0)):        super().__init__()        self.msg = str        self.image = script.render(str, BG_FG_Color[0], BG_FG_Color[1])        self.rect = self.image.get_rect()        self.rect.center = posclass HealthBar(pygame.sprite.Sprite):    def __init__(self, player, surf, dir_name="healthbars"):        super().__init__()        self.images = [            pygame.image.load(dir_name+"/bar0.png"),            pygame.image.load(dir_name+"/bar1.png"),            pygame.image.load(dir_name+"/bar2.png"),            pygame.image.load(dir_name+"/bar3.png")        ]        self.image = self.images[-1]        self.rect = self.image.get_rect()        self.rect.bottomleft = (0, surf.get_height())        self.player = player    def update(self, override=None):        if not override:            self.image = self.images[int(self.player.health)]        else:            self.image = self.images[int(override)]class PlayerCard(pygame.sprite.Sprite):    def __init__(self, player):        super().__init__()        self.image = pygame.Surface((screen.get_width()//3 - 50, screen.get_height() * 2//3))        self.rect = self.image.get_rect()        self.image.fill((0, 0, 0))        self.image.set_alpha(200)        self.player_img = pygame.transform.scale(player.image, (self.image.get_width() * 5//6, self.image.get_width() * 5//6))        self.player_rect = self.player_img.get_rect()        self.player_rect.topleft = (self.image.get_width() * 1//12, self.image.get_width() * 1//12)        tmp_font = pygame.font.Font("fonts/pixelart.ttf", 50)        self.name = player.name        self.player = player        self.name_obj = Text(player.name, (None, (155, 155, 155)), tmp_font)        self.name_obj.image.set_alpha(200)        self.name_obj.rect.center = (self.image.get_width()//2, self.image.get_height()*5//6)        self.image.blit(self.player_img, self.player_rect)        self.image.blit(self.name_obj.image, self.name_obj.rect)class Rect_Surf(pygame.sprite.Sprite):    def __init__(self, size=(10,20), color=(255,25,25), rot=0):        super().__init__()        self.image = pygame.transform.rotate(pygame.Surface(size), rot)        self.rect = self.image.get_rect()        self.image.fill(color)        self.move_coords = (0, 0)        self.move_bool = False        self.step = [0, 0]mars_level1 = Level("dual-BGs/mars-dual1.png", ("space", None), "outside-mars.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Mars Orbit", zoomMode=True, acc=0.5)mars_level2 = Level("mars.png", ("sand", None), "round-2.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5)#Stingraystorymode_3 = [    Level("nebula.png", ("neon", None), "nebula.ogg", "platform_4.png", 10, 11, False, 0.25, 15, "Somewhere", zoomMode=True),    Level("planet-orbit.png", ("neon", "cloud.png"), "planet-orbit.ogg", "platform_4.png", 10, 1, False, 1.2, 20, "Chill Clouds", acc=0.5),    Level("jungle.png", ("jungle", None), "jungle.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "Jungle Islands", zoomMode=True),    Level("wayout.png", ("jungle", None), "wayout.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "Near The Edge", zoomMode=True),    Level("uranus.png", ("space", None), "neptune.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Uranus"),    Level("uranus.png", ("space", None), "border-guard.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Border Guard", boss=Guard_01),    Level("wormhole.png", ("space", None), "wormhole.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Wormhole", zoomMode=True, acc=0.75),    mars_level1,    mars_level2,    Level("mars.png", ("sand", None), "battle-bg2.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5, boss=0),    Level("mars.png", ("sand", None), "battle-bg1.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5, boss=2)]#Waspstorymode_1 = [    Level("galaxy.png", ("space", None), "galaxy.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Outside The Milky Way", zoomMode=False),    Level("pluto.png", ("space", None), "pluto.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Pluto", zoomMode=True),    Level("neptune.png", ("space", None), "neptune.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Neptune"),    Level("unknown.png", ("neon", None), "vgm-2.ogg", "platform_1.png", 10, 11, False, 0.7, 15, "Abandoned Ship", zoomMode=True),    Level("ganymede.png", ("space", None), "nebula.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Ganymede", acc=0.75),    Level("exoplanet.png", ("jungle", "cloud.png"), "vgm.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "Ocean Moon", acc=0.75),    Level("exoplanet.png", ("jungle", None), "boss-fight.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "The Rampager", boss=Rampager),    Level("jupiter.png", ("space", None), "round-1.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Jupiter", acc=1.5),    Level("asteroid-belt.png", ("space", None), "big_asteroid.ogg", "platform_5.png", 10, 10, False, 0.5, 10, "Asteroid Belt"),    Level("asteroid.png", ("space", None), "big_asteroid.ogg", "platform_5.png", 10, 15, False, 0.5, 10, "Big Comet", zoomMode=True),    mars_level1,    mars_level2,    Level("mars.png", ("sand", None), "battle-bg2.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5, boss=1),    Level("mars.png", ("sand", None), "battle-bg1.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5, boss=2)]#Greenstorymode_2 = [    Level("watermoon.png", ("space", None), "water-moon.ogg", "platform_5.png", 10, 11, False, 1.2, 20, "Water Moon", zoomMode=False, acc=0.75),    Level("saturn.png", ("space", None), "saturn.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Saturn Orbit", zoomMode=True),    Level("saturn.png", ("space", None), "pluto.ogg", "platform_5.png", 10, 11, False, 0.3, 10, "Boss Fight!!", boss=Rampager),    mars_level1,    mars_level2,    Level("mars.png", ("sand", None), "battle-bg2.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5, boss=0),    Level("mars.png", ("sand", None), "battle-bg1.ogg", "platform_0.png", 10, 11, False, 1.2, 20, "Mars", zoomMode=True, acc=0.5, boss=1)]storymodes = [    storymode_1,    storymode_3,    storymode_2]def scanlines(thickness):    if scanlineBool:        for i in range(screen.get_height()):            if i % (thickness * 4) == 0:                tmp_line = Line(thickness, 100, (0, 0, 0), (0, i))                tmp_line.image.set_alpha(100)                scanlineGroup.add(tmp_line)scanlines(1)def returnFrames(src, size, transparency=False):    slides = cv2.VideoCapture(src)    imageList = []    while True:        ret, frame = slides.read()        if not ret:            break        shape = frame.shape[1::-1]        img = pygame.image.frombuffer(frame.tobytes(), shape, "BGR").convert_alpha()        img = pygame.transform.scale(img, size)        if transparency:            img.set_colorkey((255, 255, 255))        imageList.append(img)    slides.release()    return imageListloading = pygame.image.load("backgrounds/loading.png")loading = pygame.transform.scale(loading, res)screen.blit(loading, (0, 0))pygame.display.update()lvlSelect_Anim = returnFrames("backgrounds/levelSelect.gif", res)startup_1 = returnFrames("backgrounds/startup-1.gif", res)startup_2 = returnFrames("backgrounds/startup-2.gif", res)help_bg = returnFrames("backgrounds/help.gif", res)easter_egg = returnFrames("backgrounds/levelSelect-2.gif", res)boss_alert = returnFrames("backgrounds/red_alert.gif", res)playersList = [    PlayerObject("wasp", 1),    PlayerObject("stingray", 1),    PlayerObject("green", 1)]enemy = PlayerObject("enemy-big", 1, True)enemy2 = PlayerObject("enemy_2", 1)antagonist = PlayerObject("red", 1)enemyFreq = [1, 10]dummy1 = [playersList[0], True]dummy2 = [enemy2, True]mainPlayer = Nonedef bossLevel(level, p1, level_boss):    healthbarGroup = pygame.sprite.Group()    textGroup = pygame.sprite.Group()    monitorGroup = pygame.sprite.Group()    for item in danger:        item.remove(projGroup)        item.remove(danger)        item.kill()    for player in players.sprites():        player.remove(players)        player.kill()    for boss in bossGroup.sprites():        boss.remove(bossGroup)        boss.kill()    for item in platforms.sprites():        item.remove(platforms)        item.remove(all_sprites)        item.kill()    p1Object, p1AIBool = p1    player1 = Player(p1Object, p1AIBool)    player1.bossMode = True    player1.enemy = level_boss.enemy    level_boss.enemy = player1    level.zoomMode = False    level.loadBG(res)    level.rect.bottomleft = screen.get_rect().bottomleft    name_font = pygame.font.Font("fonts/ka1.ttf", 35)    p1Healthbar = HealthBar(player1, screen)    p1Healthbar.rect.topleft = (0, 0)    bossBar = HealthBar(level_boss, screen)    bossBar.rect.bottomleft = (0, screen.get_height())    healthbarGroup.add(p1Healthbar)    healthbarGroup.add(bossBar)    p1Name = Text("Player", (None, (255, 255, 255)), name_font, (0, 0))    p1Name.rect.topleft = p1Healthbar.rect.bottomleft    bossName = Text("Boss", (None, (255, 255, 255)), name_font, (0, 0))    bossName.rect.bottomleft = bossBar.rect.topleft    textGroup.add(p1Name)    textGroup.add(bossName)    player1.raceBool = True    players.add(player1)    bossGroup.add(level_boss)    plat1 = Platform(True, image="platforms/" + level.platDir + "/" + level.startblock)    plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 2, plat1.image.get_height() * 2))    plat1.rect = plat1.image.get_rect()    plat1.rect.midleft = (width//2, screen.get_height() * 10/12)    main_y_coord = plat1.rect.midtop[1]    tmp_plat = Platform(True, image="platforms/" + level.platDir + "/" + level.startblock)    tmp_plat.rect.midleft = plat1.rect.midright    platforms.add(plat1)    platforms.add(tmp_plat)    player1.rect.midbottom = plat1.rect.midtop    font = pygame.font.Font("fonts/ka1.ttf", 50)    speed = 1    ended = False    color = (155, 155, 155)    p1Wins = Text("Boss Defeated", (None, color), font, (screen.get_width() // 2, screen.get_height() // 2))    p2Wins = Text("You Lose!!", (None, color), font, (screen.get_width() // 2, screen.get_height() // 2))    finalWin = None    acc = level.acc    counter = 0    loss = False    level.image.set_alpha(50)    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_ESCAPE:                    enterOpp()                    startScreen()                    exit()        for player in players.sprites():            player.rect.centerx -= 1            if not ended:                if player.rect.centery > height or player.rect.midright[0] < 0 or player.rect.midleft[0] > width:                    player.health = 0        if not ended:            if speed <= 200:                speed += acc        else:            if speed >= 10:                speed -= 0.3            else:                speed = 10        for plat in platforms:            plat.rect.centerx -= int(speed//2)            if plat.rect.midright[0] < -15:                plat.remove(platforms)                plat.kill()        for i in range(10):            new_plat = Platform(True, dir=level.platDir)            new_plat.rect.midtop = (new_plat.rect.centerx, main_y_coord)            if pygame.sprite.spritecollideany(new_plat, platforms):                new_plat.kill()            else:                new_plat.add(platforms)        if level_boss.health <= 0:            ended = True            finalWin = p1Wins        if player1.health <= 0:            ended = True            loss = True            finalWin = p2Wins            player1.image = player1.blownup        if len(projGroup.sprites()) > 2:            coll = pygame.sprite.spritecollideany(projGroup.sprites()[-1], projGroup)            if coll and coll.sender != projGroup.sprites()[-1].sender:                for item in projGroup.sprites():                    item.kill()        players.update(level.jumpForce, level.gravity, otherGroup=bossGroup)        projGroup.update()        p1Healthbar.update()        bossBar.update(override=int(level_boss.health//3))        monitorGroup.update()        screen.blit(level.image, level.rect)        players.draw(screen)        projGroup.draw(screen)        if (counter//FPS) >= level_boss.delay:            bossGroup.update()            bossGroup.draw(screen)        if ended:            screen.blit(finalWin.image, finalWin.rect)            enterOpp(font="fonts/ka1.ttf", msg=finalWin.msg)            if loss:                startScreen()                exit()            else:                break        platforms.draw(screen)        healthbarGroup.draw(screen)        textGroup.draw(screen)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)        counter += speeddef levelSelect(list, func, lvlSelect_Anim=easter_egg):    font = pygame.font.Font("fonts/pixelart.ttf", 20)    headerFont = pygame.font.Font("fonts/segaArt.ttf", 70)    fontColor = (64, 125, 120)    headerColor = (69, 129, 181)    levelMenu = pygame.Surface((screen.get_width() * 2 // 3, screen.get_height()))    menuRect = levelMenu.get_rect()    menuRect.topleft = (screen.get_width() // 3, 0)    cursor = font.render(">", BG2, (55, 255, 55))    cursorRect = cursor.get_rect()    cursorRect.topleft = (0, 0)    prevWin = pygame.Surface((screen.get_width() // 3 - 20, screen.get_height() // 4))    prevRect = prevWin.get_rect()    prevRect.topleft = (10, screen.get_height() // 4)    win1 = pygame.Surface((screen.get_width()//3, screen.get_height()))    win2 = pygame.Surface((win1.get_width(), win1.get_height()))    win1.fill((0, 0, 0))    win2.fill((0, 0, 0))    win1Rect = win1.get_rect()    win2Rect = win2.get_rect()    win1Rect.topleft = (0, 0)    win2Rect.topright = (screen.get_width(), 0)    win1Prev = pygame.Surface((160, 160))    win2Prev = pygame.Surface((win1Prev.get_width(), win1Prev.get_height()))    prev1Rect = win1Prev.get_rect()    prev2Rect = win2Prev.get_rect()    prev1Rect.center = win1Rect.center    prev2Rect.center = win2Rect.center    lineList = []    bgList = []    diffList = []    playerSelect = Text("Select Character", (None, headerColor), headerFont, (screen.get_width()//2, 50))    player1 = Text("Player 1", (None, fontColor), font, (win1.get_width()//2, win1.get_height()//3))    player2 = Text("Player 2", (None, fontColor), font, (win2Rect.topleft[0] + win2.get_width()//2, win2.get_height()//3))    p1 = font.render("Player 1:", BG2, fontColor)    p2 = font.render("Player 2:", BG2, fontColor)    header = font.render("AI On/Off", BG2, (131, 214, 153))    p1On = font.render("On", BG2, (55, 255, 55))    p1Off = font.render("Off", BG2, (55, 255, 55))    p2On = font.render("On", BG2, (55, 255, 55))    p2Off = font.render("Off", BG2, (55, 255, 55))    p1_state = [True, False]    p2_state = [True, False]    p1Rect = p1.get_rect()    p2Rect = p2.get_rect()    headerRect = header.get_rect()    p1OnRect = p1On.get_rect()    p1OffRect = p1Off.get_rect()    p2OnRect = p2On.get_rect()    p2OffRect = p2Off.get_rect()    p1Itr = 1    p2Itr = 1    p1Object = None    p2Object = None    i = 0    for level in list:        tmp = font.render(level.name, BG2, fontColor)        tmpRect = tmp.get_rect()        tmpRect.topleft = (20, i * tmp.get_height() + 5)        diff = font.render(level.diff, BG2, (152, 32, 32))        diffRect = diff.get_rect()        lineList.append((tmp, tmpRect, level))        diffList.append((diff, diffRect))        if not multiBool:            image = pygame.image.load(level.bg)            image = pygame.transform.scale(image, prevWin.get_size())            rect = image.get_rect()            rect.topleft = (0, 0)            bgList.append((image, rect))        else:            image = pygame.image.load(level.bg1)            image = pygame.transform.scale(image, prevWin.get_size())            rect = image.get_rect()            rect.topleft = (0, 0)            bgList.append((image, rect))        i += 1    # clear rubish from screen    screen.fill((0, 0, 0))    itr = 0    row = 0    itrRow = [p1Itr, p2Itr]    run = True    mainLevel = None    index = 0    while run:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_UP]:                    if itr <= 0:                        itr = len(lineList) - 1                    else:                        itr -= 1                    break                if keys[K_DOWN]:                    if itr >= len(lineList) - 1:                        itr = 0                    else:                        itr += 1                    break                if keys[K_RETURN]:                    if multiBool:                        mainLevel = level                        run = False                        break                    else:                        # Needs to be fixed                        return itr                    startScreen()                    break                if keys[K_ESCAPE]:                    enterOpp()                    startScreen()                    break        tmp, lnRect, level = lineList[itr]        bgImage, bgRect = bgList[itr]        diff, diffRect = diffList[itr]        diffRect.topleft = prevRect.bottomleft        cursorRect.midright = lnRect.midleft        if index >= len(lvlSelect_Anim) - 1:           index = 0           continue        else:           index += 1        bg = lvlSelect_Anim[index]        screen.blit(bg, (0, 0))        levelMenu.fill((0, 0, 0))        levelMenu.set_alpha(150)        prevWin.blit(bgImage, bgRect)        screen.blit(diff, diffRect)        for line in lineList:            lineIMG, lineRect, tmp = line            levelMenu.blit(lineIMG, lineRect)        levelMenu.blit(cursor, cursorRect)        screen.blit(levelMenu, menuRect)        screen.blit(prevWin, prevRect)        scanlineGroup.draw(prevWin)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)    run = True    selectPlayers = True    if multiBool:        win1.set_alpha(125)        win2.set_alpha(125)        index = 0        p1Index = 0        p2Index = 1        while selectPlayers:            for event in pygame.event.get():                if event.type == pygame.QUIT:                    pygame.quit()                    exit()                if event.type == pygame.KEYDOWN:                    keys = pygame.key.get_pressed()                    if keys[K_RIGHT]:                        p1Index += 1                    if keys[K_LEFT]:                        p1Index -= 1                    if keys[K_d]:                        p2Index += 1                    if keys[K_a]:                        p2Index -= 1                    if keys[K_RETURN]:                        p1Object = playersList[p1Index]                        p2Object = playersList[p2Index]                        selectPlayers = False                        break                    if keys[K_ESCAPE]:                        levelSelect(list, func)            if index >= len(lvlSelect_Anim) - 1:                index = 0                continue            else:                index += 1            bg = lvlSelect_Anim[index]            if p1Index > len(playersList) - 1:                p1Index = 0            if p1Index < 0:                p1Index = len(playersList) - 1            if p2Index > len(playersList) - 1:                p2Index = 0            if p2Index < 0:                p2Index = len(playersList) - 1            img1 = pygame.transform.scale(playersList[p1Index].image, win1Prev.get_size())            img2 = pygame.transform.scale(playersList[p2Index].image, win2Prev.get_size())            p1Name = Text(playersList[p1Index].name, (None, headerColor), font, (win1.get_width()//2, win1.get_height() * 2//3))            p2Name = Text(playersList[p2Index].name, (None, headerColor), font, (win2Rect.topleft[0] + win2.get_width()//2, win2.get_height() * 2//3))            win1Prev.blit(img1, (0, 0))            win2Prev.blit(img2, (0, 0))            screen.blit(bg, (0, 0))            screen.blit(win1, win1Rect)            screen.blit(win2, win2Rect)            screen.blit(win1Prev, prev1Rect)            screen.blit(win2Prev, prev2Rect)            screen.blit(p1Name.image, p1Name.rect)            screen.blit(p2Name.image, p2Name.rect)            screen.blit(playerSelect.image, playerSelect.rect)            screen.blit(player1.image, player1.rect)            screen.blit(player2.image, player2.rect)            scanlineGroup.draw(screen)            pygame.display.update()            clock.tick(30)        while run:            for event in pygame.event.get():                if event.type == pygame.QUIT:                    pygame.quit()                    exit()                if event.type == pygame.KEYDOWN:                    keys = pygame.key.get_pressed()                    if keys[K_ESCAPE]:                        levelSelect(list, func)                        break                    if keys[K_RETURN]:                        enterOpp()                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        pygame.mixer.music.load("songs/" + mainLevel.bgSong)                        pygame.mixer.music.play(-1)                        func(mainLevel, p1=mainPlayer)                        break                    if keys[K_DOWN]:                        row += 1                        break                    if keys[K_UP]:                        row -= 1                        break                    if keys[K_RIGHT]:                        itrRow[row] += 1                        break                    if keys[K_LEFT]:                        itrRow[row] -= 1                        break            if itrRow[row] < 0:                itrRow[row] = 1            if itrRow[row] > 1:                itrRow[row] = 0            if row < 0:                row = 1            elif row > 1:                row = 0            p1Rect.center = (screen.get_width() // 3, screen.get_height() // 2 - 10)            p2Rect.center = (screen.get_width() // 3, screen.get_height() // 2 + 10)            headerRect.center = (screen.get_width() // 2, screen.get_height() // 2 - 50)            p1OnRect.center = (screen.get_width() * 2 // 3, screen.get_height() // 2 - 10)            p2OnRect.center = (screen.get_width() * 2 // 3, screen.get_height() // 2 + 10)            p1OffRect.center = p1OnRect.center            p2OffRect.center = p2OnRect.center            if index >= len(lvlSelect_Anim) - 1:                index = 0                continue            else:                index += 1            bg = lvlSelect_Anim[index]            screen.blit(bg, (0, 0))            if p1_state[itrRow[0]]:                screen.blit(p1On, p1OnRect)            else:                screen.blit(p1Off, p1OffRect)            if p2_state[itrRow[1]]:                screen.blit(p2On, p2OnRect)            else:                screen.blit(p2Off, p2OffRect)            if row == 0:                cursorRect.midright = p1OnRect.midleft            elif row == 1:                cursorRect.midright = p2OnRect.midleft            screen.blit(p1, p1Rect)            screen.blit(p2, p2Rect)            screen.blit(cursor, cursorRect)            screen.blit(header, headerRect)            scanlineGroup.draw(screen)            pygame.display.update()            clock.tick(30)def lvlalert(level):    font = pygame.font.Font("fonts/BEYONDCONTROL.ttf", 45)    title = Text(level.name, (None, (255,255,255)), font)    title.rect.midleft = screen.get_rect().midright    obj1 = Rect_Surf((screen.get_width()//4, screen.get_height() * 15//16), RED)    obj2 = Rect_Surf((screen.get_width() * 7//8, screen.get_height()//4), YELLOW)    print(obj1)    print(obj2)    obj1.rect.midbottom = (screen.get_width()//4, 0)    obj2.rect.midleft = (screen.get_width(), screen.get_height() * 3//4)    title.rect.midright = (0, screen.get_height()//3)    level.loadBG(screen.get_size())    i = 0    FPS = 50    alpha_val = 0    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()        if (i//FPS) <= 1.5:            if obj1.rect.midtop[1] < 0:                obj1.rect.centery += 10            if obj2.rect.center[0] > screen.get_width() * 1//2:                obj2.rect.centerx -= 10            if title.rect.center[0] < screen.get_width() * 1//2 + 20:                title.rect.centerx += 10        else:            if obj1.rect.midtop[1] <= screen.get_height():                obj1.rect.centery += 15            if obj2.rect.midright[0] > 0:                obj2.rect.centerx -= 15            if title.rect.midleft[0] <= screen.get_width():                title.rect.centerx += 15            alpha_val += 7        if alpha_val >= 255:            return         level.image.set_alpha(alpha_val)        screen.fill(BLUE)        screen.blit(level.image, level.rect)        screen.blit(obj1.image, obj1.rect)        screen.blit(obj2.image, obj2.rect)        screen.blit(title.image, title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(FPS)        i += 1def playerSelect():    cards = []    for item in playersList:        cards.append(PlayerCard(item))    cards[0].rect.midleft = screen.get_rect().midleft    cards[1].rect.center = screen.get_rect().center    cards[2].rect.midright = screen.get_rect().midright    title = Text("Select Character", (None, (255, 255, 50)), pygame.font.Font("fonts/headkick.ttf", 75))    title.rect.midtop = screen.get_rect().midtop    global CHANCE    global mainPlayer    playerIndex = 0    gifIndex = 0    keys_pressed = []    codePass = False    sequence = [K_SPACE, K_UP, K_DOWN, K_a, K_s]    while True:        cursor_1 = Text(">" + cards[playerIndex].name + " selected<", (None, (0, 255, 0)), pygame.font.Font("fonts/pixelart.ttf", 30))        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYUP:                keys_pressed.append(event.key)                break            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_LEFT:                    playerIndex -= 1                    break                if event.key == pygame.K_RIGHT:                    playerIndex += 1                    break                if event.key == pygame.K_ESCAPE:                    enterOpp()                    startScreen()                    break                if event.key == pygame.K_RETURN:                    i = 0                    while i < len(storymodes[playerIndex]):                        mainPlayer = Player(cards[playerIndex].player)                        if codePass:                            enterOpp()                            pygame.mixer.music.stop()                            pygame.mixer.music.unload()                            pygame.mixer.music.load("songs/easter_egg.ogg")                            pygame.mixer.music.play(-1)                            i = levelSelect(storymodes[playerIndex], main)                            codePass = False                        CHANCE = MAXCHANCE                        item = storymodes[playerIndex][i]                        pygame.mixer.music.stop()                        pygame.mixer.music.unload()                        if item.boss:                            incoming_boss()                            pygame.mixer.music.load("songs/" + item.bgSong)                            pygame.mixer.music.play(-1)                            if isinstance(item.boss, numbers.Number):                                bossLevel(item, (cards[playerIndex].player, False), Player(cards[item.boss].player, True, player1Bool=False, raceMode=True))                            else:                                bossLevel(item, (cards[playerIndex].player, False), item.boss())                        else:                            main(item, p1=mainPlayer)                        i += 1                    pygame.mixer.music.load("songs/level-select.ogg")                    pygame.mixer.music.play(-1)        if not codePass:            if len(keys_pressed) >= maxSeqLen:                for i in range(maxSeqLen):                    if not keys_pressed[-i] == sequence[-i]:                        codePass = False                        keys_pressed.clear()                        break                    else:                        codePass = True        gifIndex += 1        if gifIndex >= len(lvlSelect_Anim):            gifIndex = 0        bg = lvlSelect_Anim[gifIndex]        if playerIndex >= len(cards):            playerIndex = 0        if playerIndex < 0:            playerIndex = len(cards) - 1        cursor_1.rect.midtop = cards[playerIndex].rect.midbottom        screen.blit(bg, (0, 0))        screen.blit(title.image, title.rect)        for item in cards:            screen.blit(item.image, item.rect)        screen.blit(cursor_1.image, cursor_1.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def incoming_boss():    i = 0    gifIndex = 0    pygame.mixer.music.load("sounds/boss_alert.ogg")    pygame.mixer.music.play(-1)    for i in range(100):        gifIndex += 1        if gifIndex >= len(boss_alert):            gifIndex = 0        bg = boss_alert[gifIndex]        screen.blit(bg, (0, 0))        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(10)    enterOpp()def main(level, p1=None, playerSpeed=0, playerLives=3):    for plat in platforms:        plat.remove(all_sprites)        plat.remove(platforms)        plat.kill()    for item in danger:        item.remove(danger)        item.remove(all_sprites)        item.remove(platforms)        item.kill()    for item in decorations:        item.remove(all_sprites)        item.remove(decorations)        item.kill()    for item in clouds:        item.remove(all_sprites)        item.remove(clouds)        item.kill()    for item in danger:        item.remove(all_sprites)        item.remove(danger)        item.kill()    players.empty()    all_sprites.empty()    screen.fill((0, 0, 0))    pygame.display.update()    p1.raceBool = True    enemyGroup = pygame.sprite.Group()    healthBars = pygame.sprite.Group()    if level.noBG:        level.bg = None    if level.bg != None:        level.loadBG(res)    MTLength = level.length    cloudsGroup2 = pygame.sprite.Group()    # Creating background clouds    if level.cloud != None:        for i in range(15):            new_cloud = Clouds((random.randrange(0, width), random.randrange(0, height)), "backgroundObjects/" + level.cloud)            if i > 20:                new_cloud.image.set_alpha(220)                new_cloud.speed = 2                clouds.add(new_cloud)            else:                new_cloud.speed = 1                new_cloud.image.set_alpha(165)                if not pygame.sprite.spritecollide(new_cloud, clouds, False):                    clouds.add(new_cloud)        for i in range(5):            new_cloud = Clouds((random.randrange(0, width), random.randrange(height * 2//3, height)), "backgroundObjects/" + level.cloud, size=(225, 95))            new_cloud.image.set_alpha(128)            if not pygame.sprite.spritecollideany(new_cloud, cloudsGroup2):                cloudsGroup2.add(new_cloud)    # Importing global variables    global PlayerSpeed    global CHANCE    global enemyFreq    if playerSpeed == 0:        PlayerSpeed = level.psd    else:        PlayerSpeed = playerSpeed    # defining player    if p1 == None:        p1 = Player(playersList[0])    all_sprites.add(p1)    players.add(p1)    # Defining ground platform    plat1 = Platform(True, "platforms/" + level.platDir + '/' + level.startblock)    # Customizing platform    plat1.image = pygame.transform.scale(plat1.image, (plat1.image.get_width() * 3, plat1.image.get_height() * 3))    plat1.rect = plat1.image.get_rect()    plat1.rect.topleft = (50, height * 5 // 6 + 3)    plat2 = Platform(True, "platforms/" + level.platDir + '/platform_0.png')    plat2.rect.center = (width * 1.25, height * 4 // 6)    # Add initial platform to groups    platforms.add(plat1)    all_sprites.add(plat1)    platforms.add(plat2)    all_sprites.add(plat2)    # loop the background music    pygame.mixer.music.load("songs/" + level.bgSong)    pygame.mixer.music.play(-1)    lvlalert(level)    platnum = 0    # Creating font object    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    index = 0    if level.zoomMode:        bgBottomLeft = level.rect.bottomleft[1] + 50    else:        bgBottomLeft = level.rect.bottomleft[1]    countVal = 250    checkMode = False    intensity = 1    p1_liveBar = HealthBar(p1, screen, "lives")    p1_healthbar = HealthBar(p1, screen)    p1_liveBar.rect.bottomleft = p1_healthbar.rect.topleft    healthBars.add(p1_liveBar)    healthBars.add(p1_healthbar)    fightmode = False    done = False    title = pygame.font.Font("fonts/ka1.ttf", 75)    zone_finished = Text("Zone Complete", (BG2, (150, 150, 150)), title, screen.get_rect().center)    finished_shadow = Text("Zone Complete", (BG2, (0, 0, 0)), title, (width//2 + 5, height//2 + 5))    msg = Text("Press Enter", (BG2, (255, 0, 0)), sub, (width//2, height//2 + 80))    msg_shadow = Text("Press Enter", (BG2, (0, 0, 0)), sub, (width // 2 + 3, height // 2 + 83))    run = True    iterator = 0    p1.raceSpeed = 3    dist_bar = pygame.image.load("dist_sprites/dist-bar.png")    bar_rect = dist_bar.get_rect()    dist_needle = pygame.image.load("dist_sprites/dist-needle.png")    ndl_rect = dist_needle.get_rect()    bar_rect.midtop = screen.get_rect().midtop    ndl_rect.topleft = bar_rect.topleft    big_font = pygame.font.Font("fonts/Ledsim.ttf", 200)    while run:        iterator += 1        player_dist = int(p1.relpos.x // FPS)        speed_txt = Text(str(int(PlayerSpeed)), (None, (0, 255, 0)), big_font, (screen.get_width() * 5//6, screen.get_height() * 5//6))        speed_shdw = Text(str(int(PlayerSpeed)), (None, (0, 0, 0)), big_font, (speed_txt.rect.centerx + 5, speed_txt.rect.centery + 5))        if not done:            dist_pct = player_dist/MTLength            ndl_rect.topleft = (int(bar_rect.topleft[0]+((dist_bar.get_width()-3)*dist_pct)), 5)        # Window event handler        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_RETURN and done:                    pygame.mixer.music.stop()                    run = False                    p1.AIMode = False                    break                if event.key == pygame.K_9:                    p1.relpos.x = 2000*FPS                    fightmode = True                    break                if event.key == pygame.K_8:                    p1.relpos.x = (level.fl-1000)*FPS                    fightmode = False                    break        # Making the platforms move to create an illusion        # That the player is moving        for plat in platforms:            plat.rect.centerx -= PlayerSpeed        if iterator % 5 == 0:            for i in range(2):                random.seed(datetime.now())                choice = random.randint(0, int(CHANCE))                new_plat = None                if choice == 0:                    if not fightmode:                        new_plat = Platform(False, None, level.platDir)                        danger.add(new_plat)                else:                    if fightmode:                        new_plat = Platform(True, "platforms/" + level.platDir + "/" + level.startblock)                        new_plat.rect.midleft = (platforms.sprites()[-1].rect.midright[0], screen.get_height() * 5//6)                    else:                        new_plat = Platform(True, None, level.platDir)                    platnum += 1                # if platforms overlap                # remove them                if new_plat:                    if pygame.sprite.spritecollideany(new_plat, platforms) and not fightmode:                        new_plat.kill()                    else:                        platforms.add(new_plat)                        all_sprites.add(new_plat)                    if platnum % 5 == 0 and not fightmode:                        new_decor = PlatDecorations(new_plat, None, level.platDir)                        if pygame.sprite.spritecollideany(new_decor, decorations):                            new_decor.kill()                        else:                            decorations.add(new_decor)        if (player_dist) > level.fl:            fightmode = True            p1.raceBool = True        # checking if the player died        # If it happened then reset settings and run gameOver method        if not done:            if p1.rect.centery > height * 3//2 or pygame.sprite.spritecollide(p1, danger, False) or p1.rect.midright[0] < 0 or p1.health <= 0:                playerLives -= 1                if playerLives <= 0:                    PlayerSpeed = level.psd                    CHANCE = MAXCHANCE                    for item in decorations:                        all_sprites.add(item)                    for item in clouds:                        item.remove(clouds)                        item.kill()                    for plat in platforms:                        plat.remove(all_sprites)                        plat.remove(platforms)                        plat.kill()                    gameOver(p1)                else:                    p1.health=3                    pygame.mixer.music.pause()                    PlayerSpeed = 6                    p1.acc = 0                    p1.rect.midtop = screen.get_rect().midtop                    pygame.mixer.Sound("sounds/pop.wav").play()                    sleep(0.5)                    for item in seagulls.sprites():                        item.remove(seagulls)                        item.kill()                    for item in projGroup.sprites():                        item.remove(projGroup)                        item.kill()                    enterOpp()                    pygame.mixer.music.set_pos(0.0)                    pygame.mixer.music.unpause()                    lvlalert(level)        # if platform is out of screen or if there are more than 10 platforms then destroy        i = 0        for plat in platforms:            i += 1            if plat.rect.midright[0] < 0:                plat.kill()        # Seagull spawning after player distance 50000/FPS Rate        if (player_dist) > 1500:            # Chance of a seagull spawning            choice = random.randint(0, CHANCE)            # If true then spawn            if choice == 0:                for i in range(random.randrange(0, 3)):                    new_seagull = Seagull(level.platDir)                    if not pygame.sprite.spritecollide(new_seagull, seagulls, False):                        seagulls.add(new_seagull)                        all_sprites.add(new_seagull)                        danger.add(new_seagull)        if (player_dist) > MTLength and player_dist != 0:            if not done:                enterOpp(bgColor=(255, 255, 255), speed=3)                pygame.mixer.music.unload()                pygame.mixer.music.load("songs/complete-2.ogg")                pygame.mixer.music.play()                p1.AIMode = True                done = True            if done:                if PlayerSpeed < 120:                    PlayerSpeed += 0.05        # When players score divided by factor number gives a remainder of 0.        # And if player score not zero its self        countVal -= 0.0025        if countVal < 25:            countVal = 300        if not done and iterator % 11 == 0:            if p1.relpos.x % (countVal) // level.factor == 0 and p1.relpos.x != 0:                PlayerSpeed += level.acc                if (player_dist) > 50:                    if CHANCE > MAXCHANCE//4:                        CHANCE //= 1.0005        if fightmode and not done:            if (player_dist) > level.fl and iterator % 200 == 0:                tmp = Player(enemy2, True)                tmp.rect.midright = (-20, screen.get_height() * 2//3)                tmp.AIMode = True                tmp.enemy = p1                p1.enemy = tmp                tmp.raceBool = True                tmp.player1Bool = False                tmp.health = 0.5                tmp.regjump = False                tmp.raceSpeed = 5                enemyGroup.add(tmp)        else:            if len(enemyGroup.sprites()) > 0:                for sprite in enemyGroup.sprites():                    sprite.remove(enemyGroup)                    sprite.kill()        if p1.relpos.x % (countVal * 10) // level.factor == 0 and p1.relpos.x < 0:            intensity += 1        while len(enemyGroup.sprites()) > 10:            tmp = enemyGroup.sprites()[-1]            tmp.remove(enemyGroup)            tmp.kill()        # If player is too far out then push it in the middle.        if p1.rect.centerx < width//3 or p1.rect.centerx > width * 2//3:            checkMode = True        if checkMode:            if p1.rect.centerx < width//2:                p1.rect.centerx += 1            elif p1.rect.centerx > width//2:                p1.rect.centerx -= 1            else:                checkMode = False        for opp in enemyGroup.sprites():            opp.rect.center = (opp.rect.center[0] + 2, opp.rect.center[1])            if opp.rect.midright[0] > width + 20:                opp.kill()        # Updating sprite groups        clouds.update()        cloudsGroup2.update(speed=(PlayerSpeed+3), minHeight=height * 2//3)        seagulls.update()        enemyGroup.update(level.jumpForce, level.gravity, projGroup)        projGroup.update()        p1.update(level.jumpForce, level.gravity, otherGroup=projGroup)        level.rect.bottomleft = (int(index), int(bgBottomLeft))        if level.bg != None:            if done:                level.image.set_alpha(25)            screen.blit(level.image, level.rect)        else:            screen.fill(BG)        clouds.draw(screen)        decorations.update()        decorations.draw(screen)        p1_liveBar.update(playerLives)        p1_healthbar.update()        # Drawing all sprites to screen        projGroup.draw(screen)        enemyGroup.draw(screen)        #danger.draw(screen)        all_sprites.draw(screen)        cloudsGroup2.draw(screen)        screen.blit(dist_bar, bar_rect)        screen.blit(dist_needle, ndl_rect)        screen.blit(speed_shdw.image, speed_shdw.rect)        screen.blit(speed_txt.image, speed_txt.rect)        if done:            screen.blit(finished_shadow.image, finished_shadow.rect)            screen.blit(msg_shadow.image, msg_shadow.rect)            screen.blit(zone_finished.image, zone_finished.rect)            screen.blit(msg.image, msg.rect)        healthBars.draw(screen)        scanlineGroup.draw(screen)        if level.zoomMode:            index -= 0.02            if bgBottomLeft < screen.get_height() * 2 // 3 + screen.get_height():                bgBottomLeft += 0.1            else:                bgBottomLeft -= 0.1        # Refreshing screen        pygame.display.update()        clock.tick(FPS)def helpScreen():    pygame.mixer.music.load('songs/help.ogg')    headerFont = pygame.font.Font('fonts/pixelart.ttf', 50)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    fontColor = (245, 245, 245)    Title = Text("Manual", (None, fontColor), headerFont, (0, 0))    Title.rect.topleft = (60, 30)    f = open("files/help.txt", "r")    fList = f.readlines()    f.close()    index = 0    firstLine = Text(fList[0],(None, fontColor), sub, (0, 0))    firstLine.rect.topleft = Title.rect.bottomleft    lines = [firstLine]    pygame.mixer.music.play(-1)    for line in fList:        if line == firstLine:            continue        tmpLine = Text(line, (None, fontColor), sub, (0, 0))        tmpLine.rect.midtop = lines[index].rect.midbottom        lines.append(tmpLine)        index += 1    y = firstLine.rect.topleft[1]    gif_index = 0    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()            if event.type == pygame.KEYDOWN:                keys = pygame.key.get_pressed()                if keys[K_DOWN]:                    if lines[0].rect.topleft[1] < Title.rect.bottomleft[1]:                        y += 20 * 5                if keys[K_UP]:                    if lines[-1].rect.bottomleft[1] > screen.get_height() * 2//3:                        y -= 20 * 5                if keys[K_ESCAPE]:                    enterOpp()                    startScreen()                    exit()        firstLine.rect.topleft = (firstLine.rect.topleft[0], y)        index = 0        for line in lines:            if line == firstLine:                continue            line.rect.midtop = lines[index].rect.midbottom            index += 1        if gif_index >= len(help_bg) - 1:            gif_index = 0        else:            gif_index += 1        screen.blit(help_bg[gif_index], (0, 0))        for line in lines:            screen.blit(line.image, line.rect)        screen.blit(Title.image, Title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def introScreen():    font = pygame.font.Font("fonts/BEYONDCONTROL.ttf", 25)    sk_logo = pygame.image.load("icons/gameIcon.png")    hd_quality = pygame.image.load("icons/hd-quality.png")    sk_rect = sk_logo.get_rect()    q_rect = hd_quality.get_rect()    sk_rect.center = screen.get_rect().center    q_rect.center = screen.get_rect().center    text = Text("For Best Experience Use Headphones", (None, (255, 255, 255)), font)    text.rect.midtop = q_rect.midbottom    i = 0    while i < 255:        sk_logo.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(sk_logo, sk_rect)        pygame.display.update()        clock.tick(60)        i += 1    sleep(0.5)    while i > 0:        sk_logo.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(sk_logo, sk_rect)        pygame.display.update()        clock.tick(60)        i -= 1    i = 0    while i < 255:        hd_quality.set_alpha(i)        text.image.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(hd_quality, q_rect)        screen.blit(text.image, text.rect)        pygame.display.update()        clock.tick(60)        i += 1    sleep(0.5)    while i > 0:        hd_quality.set_alpha(i)        text.image.set_alpha(i)        screen.fill((0, 0, 0))        screen.blit(hd_quality, q_rect)        screen.blit(text.image, text.rect)        pygame.display.update()        clock.tick(60)        i -= 1def enterOpp(surf=screen, font="fonts/headkick.ttf", msg=None, fadeOut=True, speed=1, bgColor=(0, 0, 0), textColor=(255, 255, 255)):    win = pygame.Surface(surf.get_size())    win.fill(bgColor)    alphaVal = 0    script = pygame.font.Font(font, 50)    if msg != None:        mesg = Text(msg, (None, textColor), script, (screen.get_width()//2, screen.get_height()//2))    while alphaVal < 255:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                exit()        if fadeOut:            pygame.mixer.music.set_volume(pygame.mixer.music.get_volume()-0.01)            if pygame.mixer.music.get_volume() < 0.03:                break        win.set_alpha(int(alphaVal))        screen.blit(win, (0, 0))        if msg != None:            screen.blit(mesg.image, mesg.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)        alphaVal += speed    pygame.mixer.music.set_volume(1)def startScreen():    COLOR = (245, 245, 245)    pygame.mixer.music.load('songs/startups/startup.ogg')    header1 = pygame.font.Font('fonts/pixelart.ttf', 50)    header2 = pygame.font.Font('fonts/pixelart.ttf', 35)    sub = pygame.font.Font('fonts/pixelart.ttf', 25)    title = header1.render(name, BG2, COLOR)    sub_title = Text(subtitle, (None, COLOR), header2)    cursor = sub.render('->', BG2, (100, 255, 100))    menuText = Text("Menu", (None, COLOR), header1)    start = Text("Start", (None, COLOR), sub)    help = Text("Help", (None, COLOR), sub)    indev = Text("Indev", (None, COLOR), sub)    exit = Text("Quit", (None, COLOR), sub)    titleRect = title.get_rect()    cursorRect = cursor.get_rect()    titleRect.center = (width/2, height * 1 // 2)    menuText.rect.center = (width//2, height//3)    sub_title.rect.midtop = titleRect.midbottom    options = [start, help, indev, exit]    for i in range(len(options)):        if i > 0:            options[i].rect.midtop = options[i-1].rect.midbottom        else:            options[i].rect.center = (width//2, height//2)    global multiBool    global firstEntry    pygame.mixer.music.play(-1)    global Exit    index = 0    opIndex = 0    while not Exit:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                Exit = True        if index >= len(startup_1) - 1:            index = 0            continue        else:            index += 1        bg = startup_1[index]        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(title, titleRect)        screen.blit(sub_title.image, sub_title.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)    titleRect.center = (width / 2, height * 1 // 3)    index = 0    shade = pygame.Surface(screen.get_size())    shade.fill((0, 0, 0))    shade.set_alpha(100)    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()            if event.type == KEYDOWN or event.type == pygame.JOYBUTTONDOWN or event.type == pygame.JOYAXISMOTION:                if event.key == K_DOWN:                    opIndex += 1                    break                if event.key == K_UP:                    opIndex -= 1                    break                if event.key == pygame.K_RETURN:                    enterOpp()                    for sprite in all_sprites:                        sprite.remove(all_sprites)                        sprite.kill()                    for sprite in danger:                        sprite.remove(danger)                        sprite.kill()                    if options[opIndex] == start:                        pygame.mixer.music.load("songs/level-select.ogg")                        pygame.mixer.music.play(-1)                        playerSelect()                        startScreen()                        sys.exit()                        break                    if options[opIndex] == exit:                        pygame.quit()                        sys.exit()                        break                    if options[opIndex] == help:                        helpScreen()                        startScreen()                        sys.exit()                        break                    if options[opIndex] == indev:                        pygame.mixer.music.load("songs/border-guard.ogg")                        pygame.mixer.music.play(-1)                        bossLevel(storymode_3[5], (playersList[2], False))                        startScreen()                        sys.exit()                        break        if index >= len(startup_2) - 1:            index = 0            continue        else:            index += 1        bg = startup_2[index]        screen.fill((255, 255, 255))        screen.blit(bg, (0, 0))        screen.blit(shade, (0, 0))        if opIndex >= len(options):            opIndex = 0        if opIndex < 0:            opIndex = len(options) - 1        cursorRect.midright = options[opIndex].rect.midleft        for sprite in options:            screen.blit(sprite.image, sprite.rect)        screen.blit(cursor, cursorRect)        screen.blit(menuText.image, menuText.rect)        scanlineGroup.draw(screen)        pygame.display.update()        clock.tick(30)def gameOver(player=None):    if player != None:        player.remove(players)        player.kill()    pygame.mixer.music.load('sounds/gameOver.ogg')    pygame.mixer.music.stop()    header = pygame.font.Font('fonts/pixelart.ttf', 40)    sub = pygame.font.Font('fonts/pixelart.ttf', 20)    text = header.render('Game Over', BG, (255, 255, 255))    text2 = sub.render('Press anything to continue', BG, (255, 255, 255))    textRect = text.get_rect()    text2Rect = text2.get_rect()    textRect.midbottom = (width // 2, height // 3)    text2Rect.midbottom = (width // 2, height * 3 // 6)    screen.blit(text, textRect)    screen.blit(text2, text2Rect)    pygame.mixer.music.play(0, 0)    pygame.display.flip()    while True:        for event in pygame.event.get():            if event.type == pygame.KEYDOWN or event.type == pygame.JOYBUTTONDOWN:                sleep(0.25)                for sprite in all_sprites:                    sprite.kill()                    enterOpp()                    startScreen()                break            if event.type == pygame.QUIT:                pygame.quit()                sys.exit()        scanlineGroup.draw(screen)        pygame.display.flip()if not debug:    introScreen()startScreen()